<?xml version="1.0" encoding="UTF-8"?>
<!-- ***** BEGIN LICENSE BLOCK *****
   -
   - The Initial Developer of the Original Code is
   - Harutyun Amirjanyan <amirjanyan@gmail.com>.
   - Portions created by the Initial Developer are Copyright (C) 2010
   - the Initial Developer. All Rights Reserved.
   -
   - ***** END LICENSE BLOCK ***** -->

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">
	<binding id="urlbar" extends="chrome://browser/content/urlbarBindings.xml#urlbar" inheritstyle ="true">
		<content sizetopopup="pref" >
			<xul:hbox class="autocomplete-textbox-container urlbar-textbox-container" flex="1">
				<children includes="image|deck|stack|box">
					<xul:image class="autocomplete-icon" allowevents="true"/>
				</children>

<xul:stack flex="1" anonid="stack" class="urlbar-stack1" context=''>
    <children includes="progressmeter"/>

<xul:hbox flex="1" >
<xul:hbox flex="1" class="st-layers">
	<xul:vbox flex="1" anonid="textbox-input-box" class="textbox-input-box plain " align="stretch">
	   <xul:vbox anonid="textbox-input-box-inner" xbl:inherits="tooltiptext=inputtooltiptext"
				 flex="1" >
			<html:input anonid="input" class="autocomplete-textbox textbox-input smart-text-input" style="cursor:inherit"
						flex="1" allowevents="true"
						xbl:inherits="tooltiptext=inputtooltiptext,onfocus,onblur,value,type,maxlength,disabled,size,readonly,userAction"/>
		</xul:vbox>
	</xul:vbox>

	<html:hbox  anonid="stsegment-layer" class="smart-text" style="display:none;"
		ondragover="gURLBar.layerManager.makePlain()"  ondragexit="nsDragAndDrop.dragExit(event, gURLBar);"/>


	<xul:box anonid="overflow-ellipsis" class="smart-text-ellipsis" onclick="gURLBar.inputclicks.elipsisClick(event);"
				style="-moz-user-select:none;-moz-box-align:center" ><html:div>...</html:div></xul:box>

</xul:hbox>
</xul:hbox>

<xul:hbox flex="1" style='pointer-events:none' class="elipsis-mask" >
	<xul:vbox flex='1' class='f' >
		<xul:vbox  flex='3' style='pointer-events:auto'/>
		<xul:vbox  flex='5' style='pointer-events:auto'/>
	</xul:vbox>
	<xul:hbox style='pointer-events:auto;min-width:80px'/>
</xul:hbox>
</xul:stack>


<children includes="hbox"/>

			</xul:hbox>
			<xul:dropmarker anonid="historydropmarker" class="autocomplete-history-dropmarker urlbar-history-dropmarker" allowevents="true" xbl:inherits="open,enablehistory"/>
			<children/>
			<xul:popupset anonid="popupset" class="autocomplete-result-popupset"/>
		</content>


    <implementation implements=" nsIObserver">
    <constructor><![CDATA[  //nsIDOMEventListener,
		var p=this.parentNode
		if(p.stMouseDown)
			p.removeEventListener('mousedown',p.stMouseDown,true)
		p.addEventListener('mousedown', p.stMouseDown = this.fixGURLBarPaddingClick, true)

		this.__noSuchMethod__=dump
		this.selectionManager.init()
		this.inputclicks.init()
		this.layerManager.init()
		this.clickSelectsAll=false

		if(this.layerManager.synch(this.inputField.value))
			this.layerManager.makePretty()
        this.inputField.removeEventListener("mousemove", this, false);
        this.plain = false;
		// fix popup behaviour
		this.popup.__proto__.onPopupClick = this.popupClick
    ]]></constructor>
	<destructor><![CDATA[
        //
    ]]></destructor>

    <field name="inputBox">
        document.getAnonymousElementByAttribute(this, "anonid", "textbox-input-box");
      </field>
    <field name="inputBoxInner">
        document.getAnonymousElementByAttribute(this, "anonid", "textbox-input-box-inner");
      </field>
    <field name="stsegmentLayer">
        document.getAnonymousElementByAttribute(this, "anonid", "stsegment-layer");
    </field>
    <field name="_focused"/>


    <property name="contentIsCropped" onget="return false;" onset="return false;"/>

    <property name="value"
                onget="return this.inputField.value;">
        <setter><![CDATA[
			try{
				val = val.replace(/%../g, function(s){try{return decodeURIComponent(s)}catch(e){return s}});
			}catch(e){}

			this.mIgnoreInput = true;
			this.inputField.value = val;
			this.mIgnoreInput = false;
			if(!this._focused){
				this.layerManager.synch(val)
				if(this.plain)
					this.layerManager.makePretty()
			}
			/*var event = document.createEvent("Events");
			event.initEvent("ValueChange", true, true);
			this.inputField.dispatchEvent(event);*/
			return val;
        ]]></setter>
      </property>

	  <method name="_updateVisibleText">
        <body><![CDATA[ ]]></body>
      </method>

	  <method name="handleEvent">
        <parameter name="aEvent"/>
        <body><![CDATA[
          /*switch(aEvent.type){
            case "mousedown":
              break;
            case "mousemove":
              this._initURLTooltip();
              break;
            case "mouseout":
              this._hideURLTooltip();
              break;
          }*/
        ]]></body>
      </method>

	  <method name="_getSelectedValueForClipboard">
         <body><![CDATA[
           // Grab the actual input field's value, not our value, which could include moz-action:
           var inputVal = this.inputField.value;
           var val = inputVal.substring(this.selectionStart, this.selectionEnd);
           return val;
         ]]></body>
       </method>
<method name="popupClick"><parameter name="aEvent"/><body><![CDATA[
//  gURLBar.popup.__proto__.onPopupClick = function onPopupClick(aEvent) {
	if (aEvent.button == 2) {
		return;
	}
	var sel=getSelection(), val = sel.toString()
	if(val){
		Cc["@mozilla.org/widget/clipboardhelper;1"]
					  .getService(Ci.nsIClipboardHelper)
					  .copyString(val);
		sel.removeAllRanges()
		return
	}
	var controller = this.view.QueryInterface(Components.interfaces.nsIAutoCompleteController);
	if (aEvent.button == 0 &&
		!aEvent.shiftKey &&
		!aEvent.ctrlKey && !aEvent.altKey && !aEvent.metaKey) {
		controller.handleEnter(true);
		return;
	}
	if (gURLBar && this.mInput == gURLBar) {
		var url = controller.getValueAt(this.selectedIndex);
		//this.closePopup();//controller.handleEscape();
		let action = this.mInput._parseActionUrl(url);
		if (action) {
			if (action.type == "switchtab") {
				url = action.param;
			} else {
				return;
			}
		}
		//openLinkIn(url, whereToOpenLink(aEvent, false, true), {relatedToCurrent: true, fromChrome: false});
		gBrowser.loadOneTab(url, {inBackground: true, relatedToCurrent: true});
	}
]]></body></method>
<method name="fixGURLBarPaddingClick"><parameter name="event"/><body><![CDATA[
	//needed to allow clicks on padding
	if(event.originalTarget==gURLBar&&!gURLBar.fixPaddingClick_timeOut){
		var r=gURLBar.stsegmentLayer.getBoundingClientRect()
		if(r.left<event.clientX && event.clientX<r.right){
			event.preventDefault()
			event.stopPropagation()
			var utils = (window.getInterface ||
					window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface)(Ci.nsIDOMWindowUtils)
 			gURLBar.layerManager.elipsisMask.style.display='none'
 			gURLBar.selectionManager.fixGURLBarPaddingClick=true
			var args=['mousemove',event.clientX, r.top+2, event.button, event.clickCount, null]
			utils.sendMouseEventToWindow.apply(utils, args)
			utils.sendMouseEventToWindow.apply(utils, args)
			utils.sendMouseEventToWindow.apply(utils, args)
			this.fixPaddingClick_timeOut = true;
			setTimeout('gURLBar.fixPaddingClick_timeOut=null', 10)
			args[0]='mousedown'
			utils.sendMouseEventToWindow.apply(utils, args)
		}
	}
]]></body></method>

<field name="selectionManager"><![CDATA[({
	container : this.stsegmentLayer,
	elemCount:0,
	tokenList:[],
	setInnerHTML: function(tokenList){
		var div = document.createElementNS('http://www.w3.org/1999/xhtml','div')
		div.className = 'smart-text-inner'
		var html = []
		;(tokenList||this.tokenList).forEach(function(x){
			html.push(
				'<stsegment class="', x.class, '" index="', x.index, '">',
					x.text.replace(/[<&]/g, function(str) {return str == "&" ? "&amp;" : "&lt;";}),
				'</stsegment>'
			)
		})
		div.innerHTML = html.join('')
		var el=this.container
		while (el.hasChildNodes())
			el.removeChild(el.lastChild);
		el.appendChild(div)
	},

	getMarkedTokenList: function(st, en){
		function sub(pt, sel, a, b){
			var fr = pt.text.substring(a,b)
			var clazz = pt.class + ' marked'

			if(!fr) return
			if(sel) clazz += ' selected'
			if(a) clazz += ' first'
			if(b < pt.text.length) clazz += ' last'

			newList.push({
				text: fr,
				index: pt.index,
				class: clazz
			})
		}
		var newList = [], i=0, pt = this.tokenList[i], lastPos=0, st1, en1
		//normalize marker
		if (st > en){
			st1=st; st=en; en=st1
		} else if(st == en)
			return this.tokenList

		//before marker start
		while(pt && pt.endPos <= st){
			sub(pt, false)
			lastPos = pt.endPos
			pt = this.tokenList[++i]
		}

		//split first marked node
		st1=st-lastPos
		en1=en-lastPos
		sub(pt, false, 0, st1)
		if(en<=pt.endPos){
			sub(pt, true, st1, en1)
			sub(pt, false, en1)
		} else {
			sub(pt, true, st1)
			//next token
			lastPos = pt.endPos
			pt = this.tokenList[++i]
			while(pt && pt.endPos <= en){
				sub(pt, true)
				lastPos=pt.endPos
				pt = this.tokenList[++i]
			}
			sub(pt, true, 0, en-lastPos)
			sub(pt, false, en-lastPos)
		}

		//after marker end
		while(pt = this.tokenList[++i])
			sub(pt, false)

		return newList;
	},

	createElem:function(className,is,ip){
		if(ip<=is)
			return
		var text=this.url.substring(is,ip)
		if(!text)
			return
		if(className=="subdomain"&&text=='www.')
			className+=' www'
		else if(className=="protocol"&&text=='http://')
			className+=' www'
		this.tokenList.push({
			index: this.elemCount,
			text: text,
			class: className,
			endPos: ip
		})
		this.elemCount++;
		this.inds.push(ip)
	},

	clear : function(){
		this.elemCount=0
		this.tokenList=[]
	},

	synch: function(uri,url){
		this.clear();
		this.url=url;
		var i1
	//???????
		/*url = losslessDecodeURI(url);*/
	//create protocol node
		this.inds=[0]
		var i1= url.indexOf(":")+1
		while(url[i1]=='/') ++i1
		this.createElem("protocol",0,i1);
	//look for subdomain
		var host = uri.host, is=i1;
		if (host) {
			try {
				let baseDomain = Services.eTLD.getBaseDomainFromHost(host);
				let l=host.lastIndexOf(baseDomain)//punicode hosts
				if(l==-1){
					let i = baseDomain.split('.').length
					l=host.length
					while(i--)
						l=host.lastIndexOf('.',l-1)
					l++
				}
				is+=l
			} catch (e) {}
		}
	//look for domain
		var i2= (url.match(/(:\/(?!\/))|([^:\/](\/))|(.\?)/)||{index:-2}).index+1//.indexOf("/", uri.scheme=='file'?i1+1:i1)
		if(i2<0)
			  i2=url.length	;
	//create and fill subdomains
		//this.createElem("subdomain",i1,is);
		var ip1=ip2=i1;
		while(ip2<is){
			ip1=ip2;
			ip2 = url.indexOf(".",ip1+1)+1;
			if(ip2<0||ip2>=is)
				break;
			this.createElem("subdomain",ip1,ip2);
		}
		this.createElem("subdomain",ip1,is);
	//create and fill domain
		this.createElem("basedomain",is,i2);
		this.domainEnd=i2
	//look for query
		var i3= url.indexOf("?",i2+1)
		if(i3<0)
			i3=url.length
	//fill path
		var ip1=ip2=i2;
		while(ip2<i3){
			ip1=ip2;
			ip2 = url.indexOf("/",ip1+1);
			if(ip2<0||ip2>=i3)
				break;
			this.createElem("path",ip1,ip2);
		}
		this.createElem("path",ip1,i3);
	//look for index
		var i4= url.indexOf("#",i3+1)
		if(i4<0)
			i4=url.length
	//fill querry
		var ip1=ip2=i3;
		while(ip2<i4){
			ip1=ip2;
			ip2 = url.indexOf("&",ip1+1);
			if(ip2<0||ip2>=i4)
				break;
			this.createElem("querry",ip1,ip2);
		}
		this.createElem("querry",ip1,i4);
	//create index element
		if(i4>i3){
			this.createElem("index",i4,url.length);
		}

	//append flex at end
		this.tokenList.push({
			index: ++this.elemCount,
			text: '',
			class: "smart-text-end",
			startPos: url.length
		})
		this.setInnerHTML()
	//keep scrolled element visible
		var pn=this.container
		if(pn.scrollLeft+pn.clientWidth > pn.scrollWidth)
			pn.scrollLeft = pn.scrollWidth
		this.linkable=true
	},
	simpleSynch: function(url){
		this.inds=[0];
		this.clear();
		this.url=url
		this.createElem("empty",0,this.url.length);
	//append flex at end
		this.tokenList.push({
			index: ++this.elemCount,
			text: '',
			class: "smart-text-end",
			startPos: url.length
		})
		this.setInnerHTML()
	//keep scrolled element visible
		var pn=this.container
		if(pn.scrollLeft+pn.clientWidth > pn.scrollWidth)
			pn.scrollLeft = pn.scrollWidth
		this.linkable=false
	},
	emptySynch: function(){
		this.inds=[0];
		this.clear();
		this.url=gURLBar.emptyText||gURLBar.getAttribute('placeholder')
		this.createElem("empty",0,this.url.length);
		this.setInnerHTML()
	},

	p: document.getAnonymousElementByAttribute(this, "anonid", "input"),

	init: function(){
		this.p.addEventListener("DOMMouseScroll", function(e){
			if(e.ctrlKey){
				if(this.scroll){
					this.scroll=false
					var text=this.value,offset=e.rangeOffset,st=this.selectionStart,en=this.selectionEnd
					this.value=gURLBar.selectionManager.scrollNumbers(text,offset,(e.detail>0?-1:1))
					this.selectionStart=st;this.selectionEnd=en
				}else
					this.scroll=true
				e.preventDefault();e.stopPropagation()

			}else
				this.editor.rootElement.scrollLeft+=(e.detail>0?1:-1)*15
		}, true);

		this.container.addEventListener("DOMMouseScroll", function(e){
			if(e.ctrlKey){
				if(this.scroll){
					this.scroll=false
					gURLBar.selectionManager.scrollNumbersPretty(e)
				}else
					this.scroll=true
				e.preventDefault();e.stopPropagation()
			}else
				this.scrollLeft+=(e.detail>0?1:-1)*15
		}, true);

		this.container.addEventListener("mousedown", this, true);
	},

	scrollNumbers: function(text,offset,amount){
		var m=parseInt(text.charAt(offset))
		if(isNaN(m))
			m=parseInt(text.charAt(++offset))
		if(isNaN(m))
			m=parseInt(text.charAt(offset-=2))
		if(isNaN(m))
			return
		var len=1,max=10,m1
		m=m+amount
		while(m>=max){
			++len;--offset;
			m1=parseInt(text.charAt(offset))
			if(isNaN(m1)){
				len--;offset++;break;
			}
			m=max*m1+m
			max=10*max
		}
		while(m<0){
			++len;--offset;
			m1=parseInt(text.charAt(offset))
			if(isNaN(m1)){
				len--;offset++;break;
			}
			m=max*m1+m
			max=10*max
		}
		if(m<0)m=0
		return text.substring(0,offset)+m+text.substr(offset+len)
	},
	scrollNumbersPretty: function(e){
		var text=e.rangeParent.nodeValue,offset=e.rangeOffset,amount=e.detail>0?-1:1
		if(!text)
			return;

		var newtext=this.scrollNumbers(text,offset,amount)
		e.rangeParent.nodeValue=newtext
		var len=newtext.length-text.length
		var index=parseInt(e.rangeParent.parentNode.getAttribute('index'))
		var inds=this.inds
		text=this.p.value
		text=text.substring(0,inds[index])+newtext+text.substr(inds[index+1])
		this.url=this.p.value=text
		this.tokenList[index].text = text
		this.tokenList[index].endPos += len

		if(len!=0){
			for(var i=index+1;i<inds.length;i++){
				inds[i]+=len
				this.tokenList[index].endPos += len
			}
		}
	},

	selectFromElement: function(el){
		var st, en ;
		var ind = this.inds
		var i = parseInt(el.getAttribute('index'))

		if(i===ind.length-1){
			st=0;en=ind[i-1]
		}else if(i===ind.length){
			st=en=ind[i-1]
		}else if(i===0){
			st=ind[i];en=ind[i+1]-3
		}else{
			st=ind[i];en=ind[i+1]
		}
		this.moveSelectionToInputField(st, en);
	},

	getProtocolSuggestionHTML:function(){
		var getAboutUrls=function(){
			var l="@mozilla.org/network/protocol/about;1?what=", ans=[];
			for(var i in Cc)
				if(i.indexOf(l)==0){
					ans.push('about:'+ i.substr(l.length))
				}
			return ans.sort()
		}
		var decode = function(url){
			try{
				return decodeURIComponent(url)
			}catch(e){
				return url.replace(/%../g, function(s){try{return decodeURIComponent(s)}catch(e){return s}})
			}
		}

		var urlList=getAboutUrls()
		urlList.unshift.apply(urlList, urlList.splice(urlList.indexOf('about:config'),1))//move about:config to top

		for(var i=urlList.length; i--; )
			urlList[i]={href:urlList[i], name:urlList[i]}

		//******************
		urlList.unshift({href:'chrome://browser/content/places/places.xul',name: 'places'})
		urlList.push({href:'chrome://browser/content/browser.xul',name: ':)'})

		//****************** view-source
		var url = this.url
		//------------
		urlList.unshift({href: 'view-source:', name: 'view-source:', action: 'toggle'})
		urlList.unshift({href: 'edit:', name: 'edit:', action: 'toggle'})
		
		//------------
		/*var protocol = 'http', i = protocol.length
		if(url.substring(0, i)==protocol){
			if(url[i]='s')
				urlList.unshift({href: 'http'+url.substr(i+1), name: protocol})
			else
				urlList.unshift({href: 'https'+url.substr(i+1), name: 'https'})
		}*/
		//------------

		//****** chrome, file, resource
		try{
			var uri = makeURI(url), file;

			if(uri.schemeIs('resource')){//about?
				var ph=Services.io.getProtocolHandler('resource').QueryInterface(Ci.nsIResProtocolHandler)
				var abspath=ph.getSubstitution(uri.host)
				uri=Services.io.newURI(uri.path.substr(1), null, abspath)
			}
			while(uri.schemeIs('chrome'))
				uri=Cc["@mozilla.org/chrome/chrome-registry;1"].getService(Ci.nsIXULChromeRegistry).convertChromeURL(uri)

			if(uri.schemeIs('file')){
				file=uri.QueryInterface(Ci.nsIFileURL).file
				urlList.unshift({href: file.path, name:'filePath', action: 'setValue'})
				if(file.leafName.match(/\.(jar|zip|docx|xlsx|xpi|crx|oex)$/))
					urlList.unshift({href: 'jar:'+uri.spec+'!/', name:'jar:'})
			}else if(uri.schemeIs('jar')&&decode(uri.spec)!=decode(url)){
				urlList.unshift({href: decode(uri.spec), name:'jarPath', action: 'setValue'})
			}
		}catch(e){}

		var decoded=decode(this.url)
		if(decoded!=this.url)
			urlList.unshift({href: decoded, name:'decode', setValue: true})


		//******************
		var im=[]
		var odd = false
		for(var i=urlList.length; i--; ){
			var toc = urlList[i]
			im.unshift(
				'<stlink href="', toc.href.replace(/[<&"]/g, function(str) {return str == "&" ? "&amp;" : str =="<"? "&lt;":"&quote;"}), '"',
						toc.action?" action='"+ toc.action+"'":'',
						odd = !odd? " odd='true'":'', '>',
					toc.name,
				'</stlink>'
			)
		}
		return im
	},
	showProtocolSuggestions: function(anchorElement){
		var el =  document.getAnonymousElementByAttribute(gURLBar, "anonid", "contextPopup"),
			fc = document.createElementNS('http://www.w3.org/1999/xhtml','div')
		if(!el){
			el=document.createElement('panel')
			el.className='stPopup'
			el.setAttribute("anonid", "contextPopup")
			//el.setAttribute("type", "autocomplete-richlistbox")
			//el.setAttribute("ignorekeys", "true")
			this.container.parentNode.appendChild(el)
			el.setAttribute('onclick','gURLBar.selectionManager.onProtocolPopupClick(event)')
			el.setAttribute('onkeypress','dump(event)')


		}else if(el.state=='open'){
			el.hidePopup()
		}else{
			while (el.hasChildNodes())
				el.removeChild(el.lastChild);
		}

		fc.innerHTML=this.getProtocolSuggestionHTML().join('')

		el.appendChild(fc);

		var popupBoxObject = el.popupBoxObject;
		popupBoxObject.setConsumeRollupEvent(popupBoxObject.ROLLUP_NO_CONSUME);
		/*el.showPopup(anchorElement, -1, -1, "popup", "bottomleft", "topleft");*/
		var r = anchorElement.getBoundingClientRect()
		el.openPopup(null, "after_start", r.left-50,r.bottom)
		el.focus()
	},
	onProtocolPopupClick:function(e){
		var el = e.originalTarget
		var url = el.getAttribute('href')
		var action = el.getAttribute('action')
		
		if(action=='setValue') {
			gURLBar.value = url;
			return
		}

		if(action=='toggle') {
			var protocol = url, i = protocol.length
			url = gURLBar.value
			if(url.substring(0, i)==protocol){
				url = url.substr(url[i]=='#'?i+1:i)
			}else
				url = protocol+url			 
		}	
		
		this.openUri(e, url)
	},

	hrefFromElement: function (el) {
		var url = el.getAttribute('href')		
		if(url)return url

		var i = el.getAttribute('index')
		if(!i)return

		i = parseInt(i);
		url= this.url

		var st, en, ind = this.inds;
		if(i>=ind.length-1){
			st=0;en=ind[i-1]
		}else {
			st=ind[i];en=ind[i+1]
		}
		if(el.classList.contains("subdomain")){
			var newURL = url.substring(0, ind[0])+url.substring(ind[i+1], this.domainEnd)
		}else
			var newURL =  url.substring(0, en)
		//fixup jars
		if(newURL.substring(0,4)=='jar:'){
			if(newURL[newURL.length-1]=='!')
				newURL = newURL+'/'
			else if(newURL.indexOf('!')==-1)
				newURL = newURL.substr(4)
		}

		return newURL
	},

	selectFromRange: function () {
		var st = this.anchorOffset
		var en = this.focusOffset
		if(st>en){
			var st1 = st
			st=en
			en=st1
		}else if(st==en){//
			gURLBar.inputclicks.incrementClickCounter()
		}
		this.moveSelectionToInputField(st, en);
	},

	openUri: function(event, href){
		href=href||this.hrefFromElement(event.originalTarget)
		if(!href)
			return
		var where = whereToOpenLink(event, false, true);
		if (where == "current")
			gURLBar.value=href;
		openLinkIn(href, where,{relatedToCurrent:true,fromChrome : false})
		event.stopPropagation();
		event.preventDefault();
	},

	moveSelectionToInputField: function(start,end){
		gURLBar.layerManager.makePlain();
		this.p.focus();

		if(typeof start!=="number"||typeof end!=="number")
			this.p.select()
		else this.p.setSelectionRange(start,end)
	},

	onMouseUp: function(e, cursorMode){
		if(this.fixGURLBarPaddingClick){
			gURLBar.layerManager.elipsisMask.style.display=''
 			this.fixGURLBarPaddingClick=false
		}
		if(e.button==2){
			if(this.anchorOffset!= this.focusOffset)
				this.selectFromRange()
			else
				this.moveSelectionToInputField();
			setTimeout(function()document.getAnonymousElementByAttribute(gURLBar.inputBox,
				'anonid','input-box-contextmenu').openPopup(null,1,e.clientX+1,e.clientY+1,true,true),20)
			e.preventDefault()
			e.stopPropagation()
		}else{
			var isSel=this.anchorOffset!=this.focusOffset || cursorMode
			var state=this.state
			var cls=e.originalTarget.classList
			if(isSel || (cls.contains('empty')&&state!='left')){
				this.selectFromRange();
			}else if(state=='left' || cls.contains("smart-text-end")){
				if(e.button==1)
					this.showProtocolSuggestions(e.originalTarget)
				else
					this.moveSelectionToInputField();
			}else if(cls.contains("protocol")){
				if(!state)
					this.selectFromElement(e.originalTarget)
				else
					this.showProtocolSuggestions(e.originalTarget)
			}else{
				this.openUri(e);
			}
		}
	},

	handleEvent: function(e){
		e.preventDefault()
		e.stopPropagation()

		if(!this.p.value){
			this.moveSelectionToInputField()
			this.fixGURLBarPaddingClick=false
			return
		}
		var self = this, x, y, cursorMode, startY = e.clientY, initialClassName = this.container.className

		var onMouseMove = function(e){
			x = e.clientX, y = e.clientY
			var newFocus = self.offsetFromStart(e.rangeParent, e.rangeOffset)

			var xR=Math.abs(cursorRect.l-x)<10
			if(self.anchorOffset == newFocus && (y < visibleRect[xR?'m':'t']  || y > visibleRect.b)  ){
				if(!cursorMode){
					self.cursor.style.display = '';
					cursorMode = true;
					self.cursor.style.left = cursorRect.l + 'px';
					self.container.classList.remove('top')
				}
			}else if(cursorMode){
				self.cursor.style.display = 'none';
				cursorMode = false
				self.container.classList.add('top')
			}

			if(newFocus==self.focusOffset)
				return
			self.focusOffset = newFocus;
			self.setInnerHTML(self.getMarkedTokenList(self.anchorOffset, self.focusOffset))
		}

		var onScrollInterval = function(){
			if(x < visibleRect.l && visibleRect.scrollL > 0){
				var delta = x - visibleRect.l
				if(visibleRect.scrollL + delta < 0)
					delta = -visibleRect.scrollL
			}else if(x > visibleRect.r && visibleRect.scrollL < visibleRect.scrollW){
				var delta = x - visibleRect.r
				if(visibleRect.scrollL + delta > visibleRect.scrollW)
					delta = visibleRect.scrollW - visibleRect.scrollL
			}else
				return

			cursorRect.l -=delta
			visibleRect.scrollL += delta
			self.container.scrollLeft = visibleRect.scrollL
		}

		var onMouseUp = function(){
			window.removeEventListener("mousemove", onMouseMove, true);
			window.removeEventListener("mouseup", onMouseUp, true);
			clearInterval(timerId);
			self.cursor.style.display = 'none'
			self.container.className = initialClassName
			self.onMouseUp(e, cursorMode)
		}


		this.state = gURLBar.layerManager.lastTarget.type
		this.anchorOffset = this.focusOffset = this.offsetFromStart(e.rangeParent, e.rangeOffset)


		if(!this.cursor){
			this.cursor = this.container.parentNode.appendChild(document.createElement('stcursor'))
			this.cursor.style.cssText = 'border:1px solid;display:none;position:fixed;z-index:-1;pointer-events:none'
		}
		var visibleRect = this.container.getBoundingClientRect(), cursorRect = this.getEventPoint(e, this.anchorOffset)
		visibleRect = {
			m: visibleRect.top + visibleRect.height * 0.4,
			h: visibleRect.height,
			t: visibleRect.top,
			l: visibleRect.left,
			r: visibleRect.right,
			b: cursorRect.b,
			w: visibleRect.width,
			scrollW: this.container.scrollWidth,
			scrollL: this.container.scrollLeft
		}
		if(!this.linkable)
			visibleRect.m = visibleRect.b+10 // non uris are always selectable
		this.cursor.style.height = (visibleRect.h)+'px'

		this.container.setCapture(false)
		window.addEventListener("mouseup", onMouseUp, true);
		window.addEventListener("mousemove", onMouseMove, true);

		if(visibleRect.scrollW >= visibleRect.w)
			var timerId = setInterval(onScrollInterval, 40);
			
		if(this.fixGURLBarPaddingClick)
			this.state='left'
			
		this.state=='left'||onMouseMove(e)
	},

	getEventPoint: function(e, startOffset){
		var node = e.rangeParent, offset = e.rangeOffset
		if(node.nodeType != 3) try{
			var i = this.inds.indexOf(startOffset)-1
			if(i>0){
				node = this.container.firstChild.children[i].firstChild
				offset = node.length
			}else{
				node = this.container.firstChild.children[0].firstChild
				offset = 0
			}
		}catch(e){return {left:0, height:0}}

		var range = document.createRange();

		range.setStart(node, offset)
		range.setStart(node, offset)
		var b1 = range.getBoundingClientRect()
		range.detach()

		return {l:b1.left, h:b1.height, b:b1.bottom}
	},


	offsetFromStart: function(node, offset) {
		function getLength(node){
			if(!node)
				return 0;
			if(node.nodeType == 3 )
				return node.length
			var ch=node.childNodes
			if(!ch)
				return 0;
			var l=0,n=ch.length, i=0
			for(i=0;i<n;i++)
				l+=getLength(ch[i])
			return l
		}
		function getLength2(node, offset){
			if(!node || !offset)
				return 0;
			if(node.nodeType == 3 )
				return offset
			var ch = node.childNodes
			if(!ch)
				return 0;
			var l=0,n=offset, i=0
			for(i=0;i<n;i++)
				l+=getLength(ch[i])
			return l
		}

		var l = getLength2(node, offset)

		while(node && node !== this.container){
			var newNode = node.previousSibling
			while(newNode){
				l+=getLength(newNode)
				newNode = newNode.previousSibling
			}
			node = node.parentNode;
		}
		return  l
	}
})]]> </field>

<field name="inputclicks"><![CDATA[({
	p: this.inputField,

	init: function(){
		this.p.addEventListener("mousedown", this, true);
		this.p.addEventListener("mouseup", this, true);
	},

	stopEvent: function(event){
		event.stopPropagation();event.preventDefault()
	},

	elipsisClick: function(event){
		if(event.button==0){
			var e,l,p
			p=this.p
			l=p.value.length;
			if(l!=0&&0==p.selectionStart&&l==p.selectionEnd){
				p.selectionStart=l
			}else{
				p.select();
			}
			this.clickCount=0
		}else if(event.button==2){
			if(!gURLBar.plain){
				gURLBar.layerManager.makePlain()
				this.p.focus()
			}
			this.p.select()
			if(event.button==2)
				document.getAnonymousElementByAttribute(gURLBar.inputBox,'anonid','input-box-contextmenu').openPopup(null,1,event.clientX+1,event.clientY+1,true,true)
		}else if(event.button==1){
			openDialog('chrome://smarttext/content/options.xul','','centerscreen')
		}
	},

	incrementClickCounter: function(reset){
		clearTimeout(this.clickCountTimer);
		if(reset){
			this.clickCount=0
			return
		}
		var self=this;
		this.clickCountTimer= setTimeout(function(){
			self.clickCount=0
		}, this.DBL_CLICK_SPEED+100*Math.min(this.clickCount,3))
		this.clickCount++
	},

	handleEvent: function (event) {
	  switch (event.type) {
		case "mousedown":
			if(event.button!=0){
				this.incrementClickCounter('reset')
				return;
			}
			var p=this.p,l=p.value.length,e=event.rangeOffset;

			this.incrementClickCounter()

			var curpos=event.clientX+" "+event.clientY
			if(e==l&&(this.clickCount!==1||curpos==this.lastPos)){
				if(event.detail>1)this.stopEvent(event)
				if(p.selectionStart==l&&p.selectionEnd==l){
					p.selectionStart=0
					this.ecbc=1
				}else if(p.selectionStart==0&&p.selectionEnd==l){
					p.selectionStart=e
					this.ecbc=2
				}
			}else if(this.clickCount === 1){
			   if(event.detail>1){
					p.selectionStart=p.selectionEnd=e
					this.stopEvent(event)
			   }
			}else if(p.selectionStart==0&&p.selectionEnd==l){
				this.clickCount=0
				p.selectionStart=p.selectionEnd=e
				// this.ecbc=true
				this.stopEvent(event)
			}else{
				if(this.clickCount === 3&&e==l)
					p.select();
				else
					this.extend(p.selectionStart,p.selectionEnd)
				this.stopEvent(event)
			}
			this.lastPos=curpos
			break;
		case "mouseup":
			//handle clicking at end
			if(event.button==0&&this.ecbc){
				this.p.selectionStart=(this.ecbc==1?0:event.rangeOffset)
				this.ecbc=false
				this.clickCount=0
			}
			break;
		}
	},

	selectAll: function (event) {
		this.p.select()
	},

	DBL_CLICK_SPEED:400,
	clickCount : 0,
	clickCountTimer : null,

	selectGroup:function(index){
		var url=this.p.value
		var i1= url.indexOf("://")
		var i2= url.indexOf("/",i1+3)
		var i3= url.indexOf("?",i2+1)
		if(i3<0)
			i3=url.length
		var i4= url.indexOf("#",i2+1)
		if(i4<0)
			i4=url.length

		if(index<i1){
			this.p.setSelectionRange(0, i1);
		}else if(index<i2){
			this.p.setSelectionRange(i1, i2);
		}else if(index<i3){
			this.p.setSelectionRange(i2, i3);
		}else if(index<i4){
			this.p.setSelectionRange(i3, i4);
		}
	},

	extend: function (s, e) {
		var c="";
		var p = this.p.value;
		var index = (function (c, i) "_-: .=/&?#".indexOf(p.charAt(c), i));
		var bound = Math.min(index(s - 1) || 100, index(e) || 100) + 1;

		end = e;
		while (index(end, bound) < 0) {
			++end;
			c = p.charAt(end);
		}
		end;
		start = s - 1;
		while (index(start, bound) < 0) {
			--start;
			c = p.charAt(start);
		}
		++start;
		this.p.selectionStart = start;
		this.p.selectionEnd = end;
	}
})]]></field>

<field name="layerManager"><![CDATA[({
	bar:this,
	inputLayer: this.inputField.parentNode.parentNode,
	smartLayer: this.stsegmentLayer,
	inputElement: this.inputField,
	elipsisMask:document.getAnonymousElementByAttribute(this, "class", "elipsis-mask"),

	containerElement: this.stsegmentLayer.parentNode,
	init: function(){
		this.elipsisMask.addEventListener("mouseover", this, true)
		var l = this.elipsisMask.lastChild
		l.type = 'left'
		l.previousSibling.lastChild.type = 'top'

		this.lastTarget=l
	},
	makePretty: function(){
		this.elipsisMask.style.display=""
		this.smartLayer.style.display=""

		var pstyle=this.inputLayer.style
		pstyle.maxWidth="0"

		this.smartLayer.scrollLeft = this.inputElement.editor.rootElement.scrollLeft;
		gURLBar.plain=false;
	},
	makePlain: function(){
		this.elipsisMask.style.display="none"
		var scrollLeft=this.smartLayer.scrollLeft
		this.smartLayer.style.display="none"

		var pstyle=this.inputLayer.style
		pstyle.maxWidth=""
		//pstyle.visibility=""

		this.inputElement.editor.rootElement.scrollLeft = scrollLeft;
		gURLBar.plain=true
	},
	synch: function(val){
		var url=val
		if(!url){
			selectionManager.emptySynch()
			return true;
		}try {
			var uri = makeURI(url, null, null);
			try {
				uri = typeof uri.host != "undefined" ? uri : {};
			} catch (e) {
				uri = {};
			}
		}catch(e) {
			uri = null;
		}

		if (!uri) {
			this.bar.selectionManager.simpleSynch(url);
			return null;
		}
		this.bar.selectionManager.synch(uri, url);
		return true;
	},
	handleEvent: function(e){
		var [l1,l2]=[this.lastTarget, e.target]
		var clist=gURLBar.plain? gURLBar.layerManager.inputLayer.classList:
								 gURLBar.layerManager.smartLayer.classList;
		l1.type&&clist.remove(l1.type)
		l2.type&&clist.add(l2.type)

		//l1.style.background=''
		l1.style.pointerEvents='auto'

		//l2.style.background='rgba(150,150,200,0.1)'
		l2.style.pointerEvents='none'

		this.lastTarget=l2
	}
})]]></field>

		</implementation>
    <handlers>
<handler event="focus"><![CDATA[
	//if (this.hasAttribute("focused"))
	//	return;
	//dump('--focus', this.mIgnoreFocus, this._focused, event.originalTarget)
	if (!this._focused && (event.originalTarget == this.inputField|| event.originalTarget == this)) {
		this._focused = true;
		this.inputField.focus()
		if (!this.plain){
			this.layerManager.makePlain();
			this.inputField.select()
			this.plain=true
		}
	}
	//this.setAttribute("focused", "true");
]]></handler>
<handler event="blur"><![CDATA[
	//dump('--blur', this.mIgnoreFocus, this._focused, event.originalTarget)
	if (!this.mIgnoreFocus&&this._focused) {
		this._focused = false;
		if(this.plain){
			this.layerManager.synch(this.inputField.value)
			this.layerManager.makePretty()
		}
	}
]]></handler>
	</handlers>
		</binding>
</bindings>