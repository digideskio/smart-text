<?xml version="1.0" encoding="UTF-8"?>
<!-- ***** BEGIN LICENSE BLOCK *****
   -
   - The Initial Developer of the Original Code is
   - Harutyun Amirjanyan <amirjanyan@gmail.com>.
   - Portions created by the Initial Developer are Copyright (C) 2010
   - the Initial Developer. All Rights Reserved.
   -
   - ***** END LICENSE BLOCK ***** -->

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">
	<binding id="urlbar" extends="chrome://browser/content/urlbarBindings.xml#urlbar" inheritstyle ="true">
		<content sizetopopup="pref">
			<xul:hbox class="autocomplete-textbox-container" flex="1">
				<children includes="image|deck|stack|box">
					<xul:image class="autocomplete-icon" allowevents="true"/>
				</children>
				<xul:stack class="fission-progress-stack" flex="1" context="" >
					<children includes="progressmeter"/>
					<xul:hbox class="autocomplete-textbox-container-fission" >
<xul:stack flex="1" anonid="stack" class="urlbar-stack">
          
<xul:hbox flex="1" >
<xul:hbox flex="1" class="st-layers" >
	<xul:vbox flex="1" anonid="textbox-input-box" class="textbox-input-box plain " align="stretch">
	   <xul:vbox anonid="textbox-input-box-inner" xbl:inherits="tooltiptext=inputtooltiptext"
				 flex="1" >
			<html:input anonid="input" class="autocomplete-textbox textbox-input smart-text-input" style="cursor:inherit"
						flex="1" allowevents="true"
						xbl:inherits="tooltiptext=inputtooltiptext,onfocus,onblur,value,type,maxlength,disabled,size,readonly,userAction"/>
		</xul:vbox>
	</xul:vbox>

	<html:hbox  anonid="stsegment-layer" class="smart-text" flex="1"  style="display:none;" 
		ondragover="gURLBar.layerManager.makePlain()"  ondragexit="nsDragAndDrop.dragExit(event, gURLBar);"/>
	

	<xul:box anonid="overflow-ellipsis" class="smart-text-ellipsis" onclick="gURLBar.inputclicks.elipsisClick(event);"
				style="-moz-user-select:none;-moz-box-align:center" ><html:div>...</html:div></xul:box>

</xul:hbox>
</xul:hbox>

<xul:hbox flex="1" style='pointer-events:none' class="elipsis-mask" >
	<xul:vbox flex='1' class='f' >
		<xul:vbox  flex='3' style='pointer-events:auto'/>
		<xul:vbox  flex='5' style='pointer-events:auto'/>
	</xul:vbox>
	<xul:hbox style='pointer-events:auto;min-width:80px'/>
</xul:hbox>
</xul:stack>


<children includes="hbox"/>
					</xul:hbox>
				</xul:stack>
			</xul:hbox>
			<xul:dropmarker anonid="historydropmarker" class="autocomplete-history-dropmarker urlbar-history-dropmarker" allowevents="true" xbl:inherits="open,enablehistory"/>
			<children/>
			<xul:popupset anonid="popupset" class="autocomplete-result-popupset"/>
		</content>


    <implementation implements="nsIDOMEventListener, nsIObserver">
    <constructor><![CDATA[
		this.urlSplitter.init()
		this.selectionManager.init()
		this.inputclicks.init()
		this.layerManager.init()
		this.clickSelectsAll=false

		if(this.layerManager.synch(this.inputField.value))
			this.layerManager.makePretty()
        this.inputField.removeEventListener("mousemove", this, false);
        this.plain = false;
    ]]></constructor>
	<destructor><![CDATA[
        /**/
    ]]></destructor>

    <field name="inputBox">
        document.getAnonymousElementByAttribute(this, "anonid", "textbox-input-box");
      </field>
    <field name="inputBoxInner">
        document.getAnonymousElementByAttribute(this, "anonid", "textbox-input-box-inner");
      </field>
    <field name="stsegmentLayer">
        document.getAnonymousElementByAttribute(this, "anonid", "stsegment-layer");
    </field>
    <field name="_focused"/>
	<!-- <field name="smartTextContainer" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "smart-text")
    </field> -->



    <field name="_tldService" readonly="true"><![CDATA[
        Components.classes["@mozilla.org/network/effective-tld-service;1"]
                  .getService(Components.interfaces.nsIEffectiveTLDService);
    ]]></field>

    <property name="contentIsCropped" onget="return false;" onset="return false;"/>

    <property name="value"
                onget="return (this.hasAttribute('isempty') || this.hasAttribute('empty')) ? '' : this.inputField.value;">
        <setter><![CDATA[
			this.mIgnoreInput = true;
			this.inputField.value = val;
			this.mIgnoreInput = false;
			if(!this._focused){
				this.layerManager.synch(val)
				if(this.plain)
					this.layerManager.makePretty()
			}
			var event = document.createEvent("Events");
			event.initEvent("ValueChange", true, true);
			this.inputField.dispatchEvent(event);
			return val;
        ]]></setter>
      </property>

	  <method name="_updateVisibleText">
        <body><![CDATA[ ]]></body>
      </method>

	  <method name="handleEvent">
        <parameter name="aEvent"/>
        <body><![CDATA[
          /*switch(aEvent.type){
            case "mousedown":
              break;
            case "mousemove":
              this._initURLTooltip();
              break;
            case "mouseout":
              this._hideURLTooltip();
              break;
          }*/
        ]]></body>
      </method>
	  	
<field name="urlSplitter"><![CDATA[({
	smartTextContainer : this.stsegmentLayer,
	elemCount:0,
	tokenList:[],
	setInnerHTML: function(tokenList){
		var div = document.createElementNS('http://www.w3.org/1999/xhtml','div')
		div.className = 'smart-text'
		var html = []
		;(tokenList||this.tokenList).forEach(function(x){			
			html.push(
				'<stsegment class="', x.class, '">', 
					x.text.replace(/[<&]/g, function(str) {return str == "&" ? "&amp;" : "&lt;";}),
				'</stsegment>' 
			)
		})
		div.innerHTML = html.join('')
		var el=this.smartTextContainer
		while (el.hasChildNodes())
			el.removeChild(el.lastChild);
		el.appendChild(div)
	},
	getMarkedTokenList: function(st, en){
		var newList = [], i=0, pt = this.tokenList[i]
		while(pt.endpos <= st){		
			newList.push(pt)
			pt = this.tokenList[++i]
		}
		
		this.tokenList=gURLBar.urlSplitter.tokenList

this.tokenList=gURLBar.urlSplitter.tokenList

st=34;en=47
function sub(pt, sel, a, b){
	var fr = pt.text.substring(a,b)
	if(fr)
		newList.push({text:fr,class: pt.class+(sel?' selected':'')})
}
var newList = [], i=0, pt = this.tokenList[i], lastPos=0
while(pt && pt.endPos <= st){		
	sub(pt, false)
	lastPos = pt.endPos
	pt = this.tokenList[++i]
}


var st1=st-lastPos,en1=en-lastPos
sub(pt, false, 0, st1)
if(en<pt.endPos){
	sub(pt, true, st1, en1)
	sub(pt, false, en1)
}else{
	sub(pt, true, st1)
}

pt = this.tokenList[++i]
while(pt && pt.endPos <= en){		
	sub(pt, true)
 /* lastPos=pt.endPos*/
	pt = this.tokenList[++i]
}
while(pt){
	sub(pt, false)
	pt = this.tokenList[++i]
}
		
	},
	htmlEscape: function(str){
		return str.replace(/[<&]/g, function(str) {return str == "&" ? "&amp;" : "&lt;";});
	},
	createElem:function(className,is,ip){
		if(ip<=is)
			return
		var text=this.url.substring(is,ip)
		if(!text)
			return
		if(className=="subdomain"&&text=='www.')
			className+=' www'
		else if(className=="protocol"&&text=='http://')
			className+=' www'
		this.tokenList.push({
			index: this.elemCount,
			text: text,
			class: className,
			endPos: ip
		})
		this.elemCount++;
		this.inds.push(ip)
	},

	clear : function(){
		this.elemCount=0
		this.tokenList=[]		
	},
	init: function(){
		//this.smartTextContainer.appendChild(this.smartTextContainer.cloneNode(false))
	},

	synch: function(uri,url){
	//dump("oooo",url,uri)
		this.clear();
		this.url=url;
		var i1
	//???????
		/*url = losslessDecodeURI(url);*/
	//create protocol node
		this.inds=[0]
		var i1= url.indexOf(":")+1
		url[i1]=='/' && ++i1 && url[i1]=='/' && ++i1
		dump(i1)
		this.createElem("protocol",0,i1);
	//look for subdomain
		var host = uri.host, is=i1;
		if (host) {
			try {
				let baseDomain = gURLBar._tldService.getBaseDomainFromHost(host);
				is+=host.lastIndexOf(baseDomain)
			} catch (e) {}
		}
	//look for domain
		var i2= url.indexOf("/",uri.scheme=='file'?i1+1:i1)
		if(i2<0)
			  i2=url.length	;
	//create and fill subdomains
		//this.createElem("subdomain",i1,is);
		var ip1=ip2=i1;
		while(ip2<is){
			ip1=ip2;
			ip2 = url.indexOf(".",ip1+1)+1;
			if(ip2<0||ip2>=is)
				break;
			this.createElem("subdomain",ip1,ip2);
		}
		this.createElem("subdomain",ip1,is);
	//create and fill domain
		this.createElem("basedomain",is,i2);
		this.domainEnd=i2
	//look for query
		var i3= url.indexOf("?",i2+1)
		if(i3<0)
			i3=url.length
	//fill path
		var ip1=ip2=i2;
		while(ip2<i3){
			ip1=ip2;
			ip2 = url.indexOf("/",ip1+1);
			if(ip2<0||ip2>=i3)
				break;
			this.createElem("path",ip1,ip2);
		}
		this.createElem("path",ip1,i3);
	//look for index
		var i4= url.indexOf("#",i3+1)
		if(i4<0)
			i4=url.length
	//fill querry
		var ip1=ip2=i3;
		while(ip2<i4){
			ip1=ip2;
			ip2 = url.indexOf("&",ip1+1);
			if(ip2<0||ip2>=i4)
				break;
			this.createElem("querry",ip1,ip2);
		}
		this.createElem("querry",ip1,i4);
	//create index element
		if(i4>i3){
			this.createElem("index",i4,url.length);
		}

	//append flex at end		
		this.tokenList.push({
			index: ++this.elemCount,
			text: '',
			class: "smart-text-end",
			startPos: url.length
		})
		this.setInnerHTML()
	//keep scrolled element visible
		var pn=this.smartTextContainer
		if(pn.scrollLeft+pn.clientWidth > pn.scrollWidth)
			pn.scrollLeft = pn.scrollWidth
	},
	simpleSynch: function(url){
		this.inds=[0];
		this.clear();
		this.url=url
		this.createElem("empty",0,this.url.length);
	//append flex at end
		this.tokenList.push({
			index: ++this.elemCount,
			text: '',
			class: "smart-text-end",
			startPos: url.length
		})
		this.setInnerHTML()
	//keep scrolled element visible
		var pn=this.smartTextContainer
		if(pn.scrollLeft+pn.clientWidth > pn.scrollWidth)
			pn.scrollLeft = pn.scrollWidth
	},
	emptySynch: function(){
		this.inds=[0];
		this.clear();
		this.url=gURLBar.emptyText||gURLBar.getAttribute('placeholder')
		this.createElem("empty",0,this.url.length);
		this.setInnerHTML()
	}
})]]></field>

<field name="selectionManager"><![CDATA[({
	p1: document.getAnonymousElementByAttribute(this, "anonid", "stsegment-layer"),
	p: document.getAnonymousElementByAttribute(this, "anonid", "input"),
	init: function(){
		this.p.addEventListener("DOMMouseScroll", function(e){
			if(e.ctrlKey){
				if(this.scroll){
					this.scroll=false
					var text=this.value,offset=e.rangeOffset,st=this.selectionStart,en=this.selectionEnd
					this.value=gURLBar.selectionManager.scrollNumbers(text,offset,(e.detail>0?-1:1))
					this.selectionStart=st;this.selectionEnd=en
				}else
					this.scroll=true
				e.preventDefault();e.stopPropagation()

			}else
				this.editor.rootElement.scrollLeft+=(e.detail>0?1:-1)*15
		}, true);

		this.p1.addEventListener("DOMMouseScroll", function(e){
			if(e.ctrlKey){
				if(this.scroll){
					this.scroll=false
					gURLBar.selectionManager.scrollNumbersPretty(e)
				}else
					this.scroll=true
				e.preventDefault();e.stopPropagation()
			}else
				this.scrollLeft+=(e.detail>0?1:-1)*15
		}, true);

		this.p1.addEventListener("mousedown", this, true);
	},
	scrollNumbers: function(text,offset,amount){
		var m=parseInt(text.charAt(offset))
		if(isNaN(m))
			m=parseInt(text.charAt(++offset))
		if(isNaN(m))
			m=parseInt(text.charAt(offset-=2))
		if(isNaN(m))
			return
		var len=1,max=10,m1
		m=m+amount
		while(m>=max){
			++len;--offset;
			m1=parseInt(text.charAt(offset))
			if(isNaN(m1)){
				len--;offset++;break;
			}
			m=max*m1+m
			max=10*max
		}
		while(m<0){
			++len;--offset;
			m1=parseInt(text.charAt(offset))
			if(isNaN(m1)){
				len--;offset++;break;
			}
			m=max*m1+m
			max=10*max
		}
		if(m<0)m=0
		return text.substring(0,offset)+m+text.substr(offset+len)
	},
	scrollNumbersPretty: function(e){
		var text=e.rangeParent.nodeValue,offset=e.rangeOffset,amount=e.detail>0?-1:1
		if(!text)
			return;

		var newtext=this.scrollNumbers(text,offset,amount)
		e.rangeParent.nodeValue=newtext
		var len=newtext.length-text.length
		var index=e.rangeParent.parentNode.index
		var inds=gURLBar.urlSplitter.inds
		text=this.p.value
		text=text.substring(0,inds[index])+newtext+text.substr(inds[index+1])
		gURLBar.urlSplitter.url=this.p.value=text
		
		if(len!=0){
			for(var i=index+1;i<inds.length;i++)
				inds[i]+=len
		}
	},

	selectFromElement: function(el){
		var st, en ;
		var ind = gURLBar.urlSplitter.inds
		var i = el.index

		if(i===ind.length-1){
			st=0;en=ind[i-1]
		}else if(i===ind.length){
			st=en=ind[i-1]
		}else if(i===0){
			st=ind[i];en=ind[i+1]-3
		}else{
			st=ind[i];en=ind[i+1]
		}
		this.moveSelectionToInputField(st, en);
	},

	hrefFromElement: function (el) {
		var st, en ;
		var ind = gURLBar.urlSplitter.inds;
		var i = el.index;
		var url=gURLBar.urlSplitter.url
		if(i>=ind.length-1){
			st=0;en=ind[i-1]
		}else {
			st=ind[i];en=ind[i+1]
		}
		if(el.className==="subdomain"){
			return url.substring(0, ind[0])+url.substring(ind[i+1], gURLBar.urlSplitter.domainEnd)
		}else
			return url.substring(0, en)
	},

	selectFromRange: function () {
		var ind = gURLBar.urlSplitter.inds
		var st = ind[this.anchor.node.parentNode.index] + this.anchor.offset
		var en = ind[this.focus.node.parentNode.index] + this.focus.offset
		if(st>en){
			var st1 = st
			st=en
			en=st1
		}
		this.moveSelectionToInputField(st, en);
	},
	
	openUri: function(event){
		var href=this.hrefFromElement(event.originalTarget)
		var where = whereToOpenLink(event, false, true);
		if (where == "current")
			gURLBar.value=href;
		openLinkIn(href, where,{relatedToCurrent:true,fromChrome : false})
		event.stopPropagation();
		event.preventDefault();
	},

	moveSelectionToInputField: function(start,end){
		gURLBar.layerManager.makePlain();
		dump('before')
		this.p.focus();
		dump('before')
		
		if(typeof start!=="number"||typeof end!=="number")
			this.p.select()
		else this.p.setSelectionRange(start,end)
	},
	downcoord:[0,0],
	onMouseDown: function(event){
		
	},
	onMouseUp: function(event){
		if(event.button==2){
			this.moveSelectionToInputField();
			document.getAnonymousElementByAttribute(gURLBar.inputBox,'anonid','input-box-contextmenu').openPopup(null,1,event.clientX+1,event.clientY+1,true,true)
		}else{
			var isSel=window.getSelection().toString()
			var state=this.state
			var moveLen=Math.abs(this.downcoord[0]-event.clientX)+Math.abs(this.downcoord[1]-event.clientY)
			var cls=event.originalTarget.className
			if(cls=='empty'&&state!='left'){
				this.selectFromRange();
			}else if(isSel||(state==undefined && cls!=="protocol"&&cls!=="smart-text-end")||( moveLen>10)){
				this.selectFromRange();
			}else if(state=='left'||cls==="smart-text-end"||(state=='top' && cls==="protocol")){
				gURLBar.inputclicks.elipsisClick(event);
			}else if(cls==="protocol"&&state==undefined){
				this.selectFromElement(event.originalTarget)
			}else if(state=='top' ){
				this.openUri(event);
			}else{
				this.selectFromRange();
			}
		}
	},

	handleEvent: function(e){
		if(e.type==="mousemove"){
			this.focus = this.getEventPoint(e)	
			
			var focusRect = this.range.getBoundingClientRect()
			var w = focusRect.left-b1.left
			
			

			if(w>0){
				this.selection.style.width=w+'px'
				this.selection.style.left=b1.left+'px'
			}else if(w<0){
				this.selection.style.width=-w+'px'
				this.selection.style.left=focusRect.left+'px'
			}else{
				var moveLen=Math.abs(this.downcoord[1]-e.clientY)
				if(moveLen>2)
					w=1
				this.selection.style.width=w+'px'
				this.selection.style.left=focusRect.left+'px'
			}
				
			dump(e.rangeParent, e.rangeOffset, this.range.startOffset, this.offsetFromStart(e.rangeParent, e.rangeOffset))
			//event.preventDefault()
		}else if(e.type==="mouseup"){
			window.removeEventListener("mousemove", this, true);
			window.removeEventListener("mouseup", this, true);
			this.range = null
			this.onMouseUp(e)			
		}else if(e.type=="mousedown"){
			if(!this.p.value){
				e.preventDefault()
				this.moveSelectionToInputField()				
				return
			}
			this.downcoord = [e.clientX,e.clientY]
			this.state = gURLBar.layerManager.elipsisMask.lastTarget.type
			
			this.range = document.createRange();
			
			this.anchor = this.getEventPoint(e)			
			
			b1 = this.range.getBoundingClientRect()
			b2 = this.p1.getBoundingClientRect()
			this.selection = this.p1.appendChild(document.createElement('stselection'))
			this.selection.style.cssText = 'position:fixed;background:rgba(100,200,100,0.5);z-index:-1;pointer-events:none'+
				'left:'+(b1.left)+'px; height:'+b1.height+'px;width:1px;top:'+(b1.top)+'px;'
			
			window.addEventListener("mouseup", this, true);
			window.addEventListener("mousemove", this, true);
			this.p1.setCapture&&this.p1.setCapture(false)
		}
	},
	
	normalizePoint: function(point) {
		while (point.node.nodeType != 3 ){
			var newNode = point.node.childNodes[point.offset]
			while(!newNode){
				if(point.node === this.p1){
					//only this requires shallow dom structure
					point.node = this.p1.lastChild
					while (!point.node.lastChild||point.node.lastChild.nodeType != 3 ){
						point.node = point.node.previousSibling
					}
					point.node = point.node.lastChild
					point.offset = point.node.length
					return point
				}else{
					newNode = point.node.nextSibling;
				}
				if(!newNode)
					point.node = point.node.parentNode;
			}
			while(newNode.firstChild){
				newNode = newNode.firstChild
			}
			point.node = newNode;
			point.offset = 0
		}
		return  point
	},
	getEventPoint: function(e){
		var point = this.normalizePoint({node: e.rangeParent, offset: e.rangeOffset})
		this.range.setStart(point.node, point.offset)
		this.range.setStart(point.node, point.offset)
		return point
	},
	

	offsetFromStart: function(node, offset) {
		function getLength(node){
			if(!node)
				return 0;
			if(node.nodeType == 3 )
				return node.length
			var ch=node.childNodes
			if(!ch)
				return 0;
			var l=0,n=ch.length, i=0
			for(i=0;i<n;i++)
				l+=getLength(ch[i])
			return l
		}
		
		function getLength2(node, offset){
			if(!node || !offset)
				return 0;
			if(node.nodeType == 3 )
				return offset
			var ch = node.childNodes
			if(!ch)
				return 0;
			var l=0,n=offset, i=0
			for(i=0;i<n;i++)
				l+=getLength(ch[i])
			return l
		}
		
		var l = getLength2(node, offset)
		
		
		while(node && node !== this.p1){
			var newNode = node.previousSibling
			while(newNode){
				l+=getLength(newNode)
				newNode = newNode.previousSibling
			}
			node = node.parentNode;
		}
		
		
		return  l
	}
})]]> </field>

<field name="inputclicks"><![CDATA[({
	p: this.inputField,

	init: function(){
		this.p.addEventListener("mousedown", this, true);
		this.p.addEventListener("mouseup", this, true);
	},

	stopEvent: function(event){
		event.stopPropagation();event.preventDefault()
	},

	elipsisClick: function(event){
		if(event.button==0){
			var e,l,p
			p=this.p
			l=p.value.length;
			if(l!=0&&0==p.selectionStart&&l==p.selectionEnd){
				p.selectionStart=l
			}else{
				p.select();
			}
			this.clickCount=0
		}else if(event.button==2){
			if(!gURLBar.plain){
				gURLBar.layerManager.makePlain()
				this.p.focus()
			}
			this.p.select()
			if(event.button==2)
				document.getAnonymousElementByAttribute(gURLBar.inputBox,'anonid','input-box-contextmenu').openPopup(null,1,event.clientX+1,event.clientY+1,true,true)
		}else if(event.button==1){
			openDialog('chrome://smarttext/content/options.xul','','centerscreen')
		}
	},

	handleEvent: function (event) {
	  switch (event.type) {
		case "mousedown":
			clearTimeout(this.clickCountTimer);
			if(event.button!=0){
				clickCount=0
				return;
			}
			var p=this.p,l=p.value.length,e=event.rangeOffset;			
			
			var self=this;
			//this.state=gURLBar.layerManager.elipsisMask.lastTarget.type
			
			this.clickCountTimer=window.setTimeout(function(){dump(self.clickCount,'timer');self.clickCount=0},this.DBL_CLICK_SPEED+100*Math.min(this.clickCount,3))
			this.clickCount++
			
			var curpos=event.clientX+" "+event.clientY
			dump(e,l,this.clickCount,curpos,this.lastPos)
			if(e==l&&(this.clickCount!==1||curpos==this.lastPos)){
				if(event.detail>1)this.stopEvent(event)				
				if(p.selectionStart==l&&p.selectionEnd==l){				
					p.selectionStart=0
					this.ecbc=1			
				}else if(p.selectionStart==0&&p.selectionEnd==l){
					p.selectionStart=e
					this.ecbc=2				
				}
			}else if(this.clickCount === 1){
			   if(event.detail>1){
					p.selectionStart=p.selectionEnd=e
					this.stopEvent(event)
			   }
			}else if(p.selectionStart==0&&p.selectionEnd==l){
				this.clickCount=0
				p.selectionStart=p.selectionEnd=e
				// this.ecbc=true
				this.stopEvent(event)
			}else{
				if(this.clickCount === 3&&e==l)
					p.select();
				else
					this.extend(p.selectionStart,p.selectionEnd)
				this.stopEvent(event)
			}
			this.lastPos=curpos
			break;			
		case "mouseup":
			//handle clicking at end
			if(event.button==0&&this.ecbc){			   
				this.p.selectionStart=(this.ecbc==1?0:event.rangeOffset)
				this.ecbc=false 
				this.clickCount=0
			}
			break;
		}
	},

	selectAll: function (event) {
		this.p.select()
	},

	DBL_CLICK_SPEED:400,
	clickCount : 0,
	clickCountTimer : null,

	selectGroup:function(index){
		var url=this.p.value
		var i1= url.indexOf("://")
		var i2= url.indexOf("/",i1+3)
		var i3= url.indexOf("?",i2+1)
		if(i3<0)
			i3=url.length
		var i4= url.indexOf("#",i2+1)
		if(i4<0)
			i4=url.length

		if(index<i1){
			this.p.setSelectionRange(0, i1);
		}else if(index<i2){
			this.p.setSelectionRange(i1, i2);
		}else if(index<i3){
			this.p.setSelectionRange(i2, i3);
		}else if(index<i4){
			this.p.setSelectionRange(i3, i4);
		}
	},

	extend: function (s, e) {
		var c="";
		var p = this.p.value;
		var index = (function (c, i) "_-: .=/&?#".indexOf(p.charAt(c), i));
		var bound = Math.min(index(s - 1) || 100, index(e) || 100) + 1;

		end = e;
		while (index(end, bound) < 0) {
			++end;
			c = p.charAt(end);
		}
		end;
		start = s - 1;
		while (index(start, bound) < 0) {
			--start;
			c = p.charAt(start);
		}
		++start;
		this.p.selectionStart = start;
		this.p.selectionEnd = end;
	}
})]]></field>

<field name="layerManager"><![CDATA[({
	bar:this,
	inputLayer: this.inputField.parentNode.parentNode,
	smartLayer: this.stsegmentLayer,
	inputElement: this.inputField,
	elipsisMask:document.getAnonymousElementByAttribute(this, "class", "elipsis-mask"),

	containerElement: this.stsegmentLayer.parentNode,
	init: function(){
		//adding class first time resets original class somewhy
		this.inputLayer.className='textbox-input-box plain smart-text-input'
		this.smartLayer.className='smart-text '

		//
		this.elipsisMask.addEventListener("mouseover",this.m1,true)
		var l=this.elipsisMask.lastChild
		l.type='left'
		l.previousSibling.lastChild.type='top'

		this.elipsisMask.lastTarget=l
	},
	makePretty: function(){
		this.elipsisMask.style.display=""
		this.smartLayer.style.display=""

		var pstyle=this.inputLayer.style
		pstyle.maxWidth="0"

		this.smartLayer.scrollLeft = this.inputElement.editor.rootElement.scrollLeft;
		gURLBar.plain=false;
	},
	makePlain: function(){
		this.elipsisMask.style.display="none"
		var scrollLeft=this.smartLayer.scrollLeft
		this.smartLayer.style.display="none"

		var pstyle=this.inputLayer.style
		pstyle.maxWidth=""
		//pstyle.visibility=""

		this.inputElement.editor.rootElement.scrollLeft = scrollLeft;
		gURLBar.plain=true
	},
	synch: function(val){
		var url=val
		if(!url){
			urlSplitter.emptySynch()
			return true;
		}try {
			var uri = makeURI(url, null, null);
			uri = (typeof uri.host != "undefined") ? uri : null;
		}catch(e) {
			uri = null;
		}
		if (!uri) {
			this.bar.urlSplitter.simpleSynch(url);
			return null;
		}
		this.bar.urlSplitter.synch(uri,url);
		return true;
	},
	m1: function(e){
		var [l1,l2]=[this.lastTarget,e.target]
		var clist=gURLBar.plain? gURLBar.layerManager.inputLayer.classList:
								 gURLBar.layerManager.smartLayer.classList;
		l1.type&&clist.remove(l1.type)
		l2.type&&clist.add(l2.type)

		//l1.style.background=''
		l1.style.pointerEvents='auto'

		//l2.style.background='rgba(150,150,200,0.1)'
		l2.style.pointerEvents='none'

		this.lastTarget=l2
	}
})]]></field>

		</implementation>
    <handlers>
<handler event="focus"><![CDATA[
	//if (this.hasAttribute("focused"))
	//	return;
	//dump('--focus', this.mIgnoreFocus, this._focused, event.originalTarget)
	if (!this._focused && (event.originalTarget == this.inputField|| event.originalTarget == this)) {
		this._focused = true;
		this.inputField.focus()
		if (!this.plain){
			this.layerManager.makePlain();
			this.inputField.select()
			this.plain=true
		}
	}
	//this.setAttribute("focused", "true");
]]></handler>
<handler event="blur"><![CDATA[
	//dump('--blur', this.mIgnoreFocus, this._focused, event.originalTarget)
	if (!this.mIgnoreFocus&&this._focused) {
		this._focused = false;
		if(this.plain){
			this.layerManager.synch(this.inputField.value)
			this.layerManager.makePretty()
		}
	}
]]></handler>
	</handlers>
		</binding>
</bindings>