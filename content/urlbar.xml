<?xml version="1.0" encoding="UTF-8"?>
<!-- ***** BEGIN LICENSE BLOCK *****
   -
   - The Initial Developer of the Original Code is
   - Harutyun Amirjanyan <amirjanyan@gmail.com>.
   - Portions created by the Initial Developer are Copyright (C) 2010
   - the Initial Developer. All Rights Reserved.
   -
   - ***** END LICENSE BLOCK ***** -->

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">
	<binding id="urlbar" extends="chrome://browser/content/urlbarBindings.xml#urlbar" inheritstyle ="true">
		<content sizetopopup="pref" >
			<xul:hbox class="autocomplete-textbox-container" flex="1">
				<children includes="image|deck|stack|box">
					<xul:image class="autocomplete-icon" allowevents="true"/>
				</children>

<xul:stack flex="1" anonid="stack" class="urlbar-stack1">
    <children includes="progressmeter"/>

<xul:hbox flex="1" >
<xul:hbox flex="1" class="st-layers" context=''>
	<xul:vbox flex="1" anonid="textbox-input-box" class="textbox-input-box plain " align="stretch">
	   <xul:vbox anonid="textbox-input-box-inner" xbl:inherits="tooltiptext=inputtooltiptext"
				 flex="1" >
			<html:input anonid="input" class="autocomplete-textbox textbox-input smart-text-input" style="cursor:inherit"
						flex="1" allowevents="true"
						xbl:inherits="tooltiptext=inputtooltiptext,onfocus,onblur,value,type,maxlength,disabled,size,readonly,userAction"/>
		</xul:vbox>
	</xul:vbox>

	<html:hbox  anonid="stsegment-layer" class="smart-text" flex="1"  style="display:none;" 
		ondragover="gURLBar.layerManager.makePlain()"  ondragexit="nsDragAndDrop.dragExit(event, gURLBar);"/>
	

	<xul:box anonid="overflow-ellipsis" class="smart-text-ellipsis" onclick="gURLBar.inputclicks.elipsisClick(event);"
				style="-moz-user-select:none;-moz-box-align:center" ><html:div>...</html:div></xul:box>

</xul:hbox>
</xul:hbox>

<xul:hbox flex="1" style='pointer-events:none' class="elipsis-mask" >
	<xul:vbox flex='1' class='f' >
		<xul:vbox  flex='3' style='pointer-events:auto'/>
		<xul:vbox  flex='5' style='pointer-events:auto'/>
	</xul:vbox>
	<xul:hbox style='pointer-events:auto;min-width:80px'/>
</xul:hbox>
</xul:stack>


<children includes="hbox"/>

			</xul:hbox>
			<xul:dropmarker anonid="historydropmarker" class="autocomplete-history-dropmarker urlbar-history-dropmarker" allowevents="true" xbl:inherits="open,enablehistory"/>
			<children/>
			<xul:popupset anonid="popupset" class="autocomplete-result-popupset"/>
		</content>


    <implementation implements="nsIDOMEventListener, nsIObserver">
    <constructor><![CDATA[
		
/*gURLBar.addEventListener('mousedown',st=function(e){

},true)*/
		
		this.__noSuchMethod__=dump
		this.selectionManager.init()
		this.inputclicks.init()
		this.layerManager.init()
		this.clickSelectsAll=false

		if(this.layerManager.synch(this.inputField.value))
			this.layerManager.makePretty()
        this.inputField.removeEventListener("mousemove", this, false);
        this.plain = false;
		// fix popup behaviour
		this.popup.__proto__.onPopupClick = this.popupClick
    ]]></constructor>
	<destructor><![CDATA[
        /**/
    ]]></destructor>

    <field name="inputBox">
        document.getAnonymousElementByAttribute(this, "anonid", "textbox-input-box");
      </field>
    <field name="inputBoxInner">
        document.getAnonymousElementByAttribute(this, "anonid", "textbox-input-box-inner");
      </field>
    <field name="stsegmentLayer">
        document.getAnonymousElementByAttribute(this, "anonid", "stsegment-layer");
    </field>
    <field name="_focused"/>
	

    <property name="contentIsCropped" onget="return false;" onset="return false;"/>

    <property name="value"
                onget="return (this.hasAttribute('isempty') || this.hasAttribute('empty')) ? '' : this.inputField.value;">
        <setter><![CDATA[
			try{
				val = val.replace(/%../g, function(s){try{return decodeURIComponent(s)}catch(e){return s}});
			}catch(e){}
			
			this.mIgnoreInput = true;
			this.inputField.value = val;
			this.mIgnoreInput = false;
			if(!this._focused){
				this.layerManager.synch(val)
				if(this.plain)
					this.layerManager.makePretty()
			}
			/*var event = document.createEvent("Events");
			event.initEvent("ValueChange", true, true);
			this.inputField.dispatchEvent(event);*/
			return val;
        ]]></setter>
      </property>

	  <method name="_updateVisibleText">
        <body><![CDATA[ ]]></body>
      </method>

	  <method name="handleEvent">
        <parameter name="aEvent"/>
        <body><![CDATA[
          /*switch(aEvent.type){
            case "mousedown":
              break;
            case "mousemove":
              this._initURLTooltip();
              break;
            case "mouseout":
              this._hideURLTooltip();
              break;
          }*/
        ]]></body>
      </method>
	  
	  <method name="_getSelectedValueForClipboard">
         <body><![CDATA[
           // Grab the actual input field's value, not our value, which could include moz-action:
           var inputVal = this.inputField.value;
           var val = inputVal.substring(this.selectionStart, this.selectionEnd);
           return val;
         ]]></body>
       </method>
	  <method name="popupClick">
        <parameter name="aEvent"/>
        <body><![CDATA[
        //  gURLBar.popup.__proto__.onPopupClick = function onPopupClick(aEvent) {
			if (aEvent.button == 2) {
				return;
			}
			var sel=getSelection(), val = sel.toString()
			if(val){
				Cc["@mozilla.org/widget/clipboardhelper;1"]
							  .getService(Ci.nsIClipboardHelper)
							  .copyString(val);
				sel.removeAllRanges()
				return
			}
			var controller = this.view.QueryInterface(Components.interfaces.nsIAutoCompleteController);
			if (aEvent.button == 0 &&
				!aEvent.shiftKey &&
				!aEvent.ctrlKey && !aEvent.altKey && !aEvent.metaKey) {
				controller.handleEnter(true);
				return;
			}
			if (gURLBar && this.mInput == gURLBar) {
				var url = controller.getValueAt(this.selectedIndex);
				//this.closePopup();//controller.handleEscape();
				let action = this.mInput._parseActionUrl(url);
				if (action) {
					if (action.type == "switchtab") {
						url = action.param;
					} else {
						return;
					}
				}
				//openLinkIn(url, whereToOpenLink(aEvent, false, true), {relatedToCurrent: true, fromChrome: false});
				gBrowser.loadOneTab(url, {inBackground: true, relatedToCurrent: true});
			}
        ]]></body>
      </method>
	  	
<field name="selectionManager"><![CDATA[({
	container : this.stsegmentLayer,
	elemCount:0,
	tokenList:[],
	setInnerHTML: function(tokenList){
		var div = document.createElementNS('http://www.w3.org/1999/xhtml','div')
		div.className = 'smart-text-inner'
		var html = []
		;(tokenList||this.tokenList).forEach(function(x){			
			html.push(
				'<stsegment class="', x.class, '" index="', x.index, '">', 
					x.text.replace(/[<&]/g, function(str) {return str == "&" ? "&amp;" : "&lt;";}),
				'</stsegment>' 
			)
		})
		div.innerHTML = html.join('')
		var el=this.container
		while (el.hasChildNodes())
			el.removeChild(el.lastChild);
		el.appendChild(div)
	},
	
	getMarkedTokenList: function(st, en){
		function sub(pt, sel, a, b){
			var fr = pt.text.substring(a,b)
			var class = pt.class + ' marked'
			
			if(!fr) return
			if(sel) class += ' selected'
			if(a) class += ' first'
			if(b < pt.text.length) class += ' last'
			
			newList.push({
				text: fr,
				index: pt.index,
				class: class
			})
		}
		var newList = [], i=0, pt = this.tokenList[i], lastPos=0, st1, en1
		//normalize marker
		if (st > en){
			st1=st; st=en; en=st1
		} else if(st == en)
			return this.tokenList
			
		//before marker start
		while(pt && pt.endPos <= st){		
			sub(pt, false)
			lastPos = pt.endPos
			pt = this.tokenList[++i]
		}

		//split first marked node
		st1=st-lastPos
		en1=en-lastPos
		sub(pt, false, 0, st1)
		if(en<=pt.endPos){
			sub(pt, true, st1, en1)
			sub(pt, false, en1)
		} else {
			sub(pt, true, st1)
			//next token
			lastPos = pt.endPos
			pt = this.tokenList[++i]
			while(pt && pt.endPos <= en){		
				sub(pt, true)
				lastPos=pt.endPos
				pt = this.tokenList[++i]
			}
			sub(pt, true, 0, en-lastPos)
			sub(pt, false, en-lastPos)			
		}		
		
		//after marker end
		while(pt = this.tokenList[++i])
			sub(pt, false)
		
		return newList;
	},
	
	createElem:function(className,is,ip){
		if(ip<=is)
			return
		var text=this.url.substring(is,ip)
		if(!text)
			return
		if(className=="subdomain"&&text=='www.')
			className+=' www'
		else if(className=="protocol"&&text=='http://')
			className+=' www'
		this.tokenList.push({
			index: this.elemCount,
			text: text,
			class: className,
			endPos: ip
		})
		this.elemCount++;
		this.inds.push(ip)
	},

	clear : function(){
		this.elemCount=0
		this.tokenList=[]		
	},
	
	synch: function(uri,url){
	//dump("oooo",url,uri)
		this.clear();
		this.url=url;
		var i1
	//???????
		/*url = losslessDecodeURI(url);*/
	//create protocol node
		this.inds=[0]
		var i1= url.indexOf(":")+1
		url[i1]=='/' && ++i1 && url[i1]=='/' && ++i1
		this.createElem("protocol",0,i1);
	//look for subdomain
		var host = uri.host, is=i1;
		if (host) {
			try {
				let baseDomain = Services.eTLD.getBaseDomainFromHost(host);
				is+=host.lastIndexOf(baseDomain)
			} catch (e) {}
		}
	//look for domain
		var i2= (url.match(/(:\/(?!\/))|([^:\/](\/))|(.\?)/)||{index:-2}).index+1//.indexOf("/", uri.scheme=='file'?i1+1:i1)
		if(i2<0)
			  i2=url.length	;
	//create and fill subdomains
		//this.createElem("subdomain",i1,is);
		var ip1=ip2=i1;
		while(ip2<is){
			ip1=ip2;
			ip2 = url.indexOf(".",ip1+1)+1;
			if(ip2<0||ip2>=is)
				break;
			this.createElem("subdomain",ip1,ip2);
		}
		this.createElem("subdomain",ip1,is);
	//create and fill domain
		this.createElem("basedomain",is,i2);
		this.domainEnd=i2
	//look for query
		var i3= url.indexOf("?",i2+1)
		if(i3<0)
			i3=url.length
	//fill path
		var ip1=ip2=i2;
		while(ip2<i3){
			ip1=ip2;
			ip2 = url.indexOf("/",ip1+1);
			if(ip2<0||ip2>=i3)
				break;
			this.createElem("path",ip1,ip2);
		}
		this.createElem("path",ip1,i3);
	//look for index
		var i4= url.indexOf("#",i3+1)
		if(i4<0)
			i4=url.length
	//fill querry
		var ip1=ip2=i3;
		while(ip2<i4){
			ip1=ip2;
			ip2 = url.indexOf("&",ip1+1);
			if(ip2<0||ip2>=i4)
				break;
			this.createElem("querry",ip1,ip2);
		}
		this.createElem("querry",ip1,i4);
	//create index element
		if(i4>i3){
			this.createElem("index",i4,url.length);
		}

	//append flex at end		
		this.tokenList.push({
			index: ++this.elemCount,
			text: '',
			class: "smart-text-end",
			startPos: url.length
		})
		this.setInnerHTML()
	//keep scrolled element visible
		var pn=this.container
		if(pn.scrollLeft+pn.clientWidth > pn.scrollWidth)
			pn.scrollLeft = pn.scrollWidth
		this.linkable=true
	},
	simpleSynch: function(url){		
		this.inds=[0];
		this.clear();
		this.url=url
		this.createElem("empty",0,this.url.length);
	//append flex at end
		this.tokenList.push({
			index: ++this.elemCount,
			text: '',
			class: "smart-text-end",
			startPos: url.length
		})
		this.setInnerHTML()
	//keep scrolled element visible
		var pn=this.container
		if(pn.scrollLeft+pn.clientWidth > pn.scrollWidth)
			pn.scrollLeft = pn.scrollWidth
		this.linkable=false
	},
	emptySynch: function(){
		this.inds=[0];
		this.clear();
		this.url=gURLBar.emptyText||gURLBar.getAttribute('placeholder')
		this.createElem("empty",0,this.url.length);
		this.setInnerHTML()
	},

	p: document.getAnonymousElementByAttribute(this, "anonid", "input"),
	
	init: function(){
		this.p.addEventListener("DOMMouseScroll", function(e){
			if(e.ctrlKey){
				if(this.scroll){
					this.scroll=false
					var text=this.value,offset=e.rangeOffset,st=this.selectionStart,en=this.selectionEnd
					this.value=gURLBar.selectionManager.scrollNumbers(text,offset,(e.detail>0?-1:1))
					this.selectionStart=st;this.selectionEnd=en
				}else
					this.scroll=true
				e.preventDefault();e.stopPropagation()

			}else
				this.editor.rootElement.scrollLeft+=(e.detail>0?1:-1)*15
		}, true);

		this.container.addEventListener("DOMMouseScroll", function(e){
			if(e.ctrlKey){
				if(this.scroll){
					this.scroll=false
					gURLBar.selectionManager.scrollNumbersPretty(e)
				}else
					this.scroll=true
				e.preventDefault();e.stopPropagation()
			}else
				this.scrollLeft+=(e.detail>0?1:-1)*15
		}, true);

		this.container.addEventListener("mousedown", this, true);
	},
	
	scrollNumbers: function(text,offset,amount){
		var m=parseInt(text.charAt(offset))
		if(isNaN(m))
			m=parseInt(text.charAt(++offset))
		if(isNaN(m))
			m=parseInt(text.charAt(offset-=2))
		if(isNaN(m))
			return
		var len=1,max=10,m1
		m=m+amount
		while(m>=max){
			++len;--offset;
			m1=parseInt(text.charAt(offset))
			if(isNaN(m1)){
				len--;offset++;break;
			}
			m=max*m1+m
			max=10*max
		}
		while(m<0){
			++len;--offset;
			m1=parseInt(text.charAt(offset))
			if(isNaN(m1)){
				len--;offset++;break;
			}
			m=max*m1+m
			max=10*max
		}
		if(m<0)m=0
		return text.substring(0,offset)+m+text.substr(offset+len)
	},
	scrollNumbersPretty: function(e){
		var text=e.rangeParent.nodeValue,offset=e.rangeOffset,amount=e.detail>0?-1:1
		if(!text)
			return;

		var newtext=this.scrollNumbers(text,offset,amount)
		e.rangeParent.nodeValue=newtext
		var len=newtext.length-text.length
		var index=parseInt(e.rangeParent.parentNode.getAttribute('index'))
		var inds=this.inds
		text=this.p.value
		text=text.substring(0,inds[index])+newtext+text.substr(inds[index+1])
		this.url=this.p.value=text
		this.tokenList[index].text = text
		this.tokenList[index].endPos += len
		
		if(len!=0){
			for(var i=index+1;i<inds.length;i++){
				inds[i]+=len
				this.tokenList[index].endPos += len
			}
		}
	},

	selectFromElement: function(el){
		var st, en ;
		var ind = this.inds
		var i = parseInt(el.getAttribute('index'))

		if(i===ind.length-1){
			st=0;en=ind[i-1]
		}else if(i===ind.length){
			st=en=ind[i-1]
		}else if(i===0){
			st=ind[i];en=ind[i+1]-3
		}else{
			st=ind[i];en=ind[i+1]
		}
		this.moveSelectionToInputField(st, en);
	},

	getProtocolSuggestionHTML:function(){
		var getAboutUrls=function(){
			var l="@mozilla.org/network/protocol/about;1?what=", it;
			var ans=[];
			for(var i in Cc)
				if(i.indexOf(l)==0){
					ans.push('about:'+ i.substr(l.length))
				}
			return ans.sort()
		}
		var decode = function(url){
			try{
				return decodeURIComponent(url)			
			}catch(e){
				return url.replace(/%../g, function(s){try{return decodeURIComponent(s)}catch(e){return s}})
			}
		}
		
		var urlList=getAboutUrls()
		urlList.unshift.apply(urlList, urlList.splice(urlList.indexOf('about:config'),1))//move about:config to top

		for(var i=urlList.length; i--; )
			urlList[i]={href:urlList[i], name:urlList[i]}
		
		//******************
		urlList.unshift({href:'chrome://browser/content/places/places.xul',name: 'places'})
		urlList.push({href:'chrome://browser/content/browser.xul',name: ':)'})

		//****************** view-source
		var url = this.url
		//------------
		var protocol = 'view-source:', i = protocol.length
		if(url.substring(0, i)==protocol){
			urlList.unshift({href: url.substr(i+1), name: protocol})
		}else
			urlList.unshift({href: protocol+url, name: protocol})
		//------------
		/*var protocol = 'http', i = protocol.length
		if(url.substring(0, i)==protocol){
			if(url[i]='s')
				urlList.unshift({href: 'http'+url.substr(i+1), name: protocol})
			else
				urlList.unshift({href: 'https'+url.substr(i+1), name: 'https'})
		}*/
		//------------
		var protocol = 'edit:', i = protocol.length
		if(url.substring(0, i)==protocol){
			urlList.unshift({href: url.substr(i+1), name: protocol})
		}else
			urlList.unshift({href: protocol+url, name: protocol})
		//****** chrome, file, resource
		try{
			var uri = makeURI(url), file;
						
			if(uri.schemeIs('resource')){//about?
				var ph=Services.io.getProtocolHandler('resource').QueryInterface(Ci.nsIResProtocolHandler)
				var abspath=ph.getSubstitution(uri.host)
				uri=Services.io.newURI(uri.path.substr(1), null, abspath)
			}
			while(uri.schemeIs('chrome')) 
				uri=Cc["@mozilla.org/chrome/chrome-registry;1"].getService(Ci.nsIXULChromeRegistry).convertChromeURL(uri)

			if(uri.schemeIs('file')){
				file=uri.QueryInterface(Ci.nsIFileURL).file
				urlList.unshift({href: file.path, name:'filePath', setValue: true})
				if(file.leafName.match(/\.(jar|zip|docx|xlsx|xpi|crx|oex)$/))
					urlList.unshift({href: 'jar:'+uri.spec+'!/', name:'jar:'})
			}else if(uri.schemeIs('jar')&&decode(uri.spec)!=decode(url)){
				urlList.unshift({href: decode(uri.spec), name:'jarPath', setValue: true})
			}
		}catch(e){}

		var decoded=decode(this.url)
		if(decoded!=this.url)
			urlList.unshift({href: decoded, name:'decode', setValue: true})
			
		
		//******************
		var im=[]
		var odd = false
		for(var i=urlList.length; i--; ){
			var toc = urlList[i]
			im.unshift(				
				'<stlink href="', toc.href.replace(/[<&"]/g, function(str) {return str == "&" ? "&amp;" : str =="<"? "&lt;":"&quote;"}), '"',
						toc.setValue?" setValue='true'":'',
						odd = !odd? " odd='true'":'', '>',
					toc.name,
				'</stlink>'
			)
		}
		return im
	},
	showProtocolSuggestions: function(anchorElement){
		var el =  document.getAnonymousElementByAttribute(gURLBar, "anonid", "contextPopup"), 
			fc = document.createElementNS('http://www.w3.org/1999/xhtml','div')
		if(!el){
			el=document.createElement('panel')
			el.className='stPopup'
			el.setAttribute("anonid", "contextPopup")
			//el.setAttribute("type", "autocomplete-richlistbox")
			//el.setAttribute("ignorekeys", "true")
			this.container.parentNode.appendChild(el)
			el.setAttribute('onclick','gURLBar.selectionManager.openUri(event)')
			el.setAttribute('onkeypress','dump(event)')
			
			
		}else if(el.state=='open'){			
			el.hidePopup()
		}else{
			while (el.hasChildNodes())
				el.removeChild(el.lastChild);
		}
		
		fc.innerHTML=this.getProtocolSuggestionHTML().join('')
		
		el.appendChild(fc);

		/*var popupBoxObject = el.popupBoxObject;
		popupBoxObject.setConsumeRollupEvent(popupBoxObject.ROLLUP_NO_CONSUME);
		el.showPopup(anchorElement, -1, -1, "popup", "bottomleft", "topleft");*/
		el.openPopup(this.container, "after_start", -50,0)
		el.focus()
	},
	/*onProtocolPopupClick:function(){
		
	},*/
	
	hrefFromElement: function (el) {
		var url = el.getAttribute('href')
		if(el.getAttribute('setValue')) {
			gURLBar.value = url;
			return
		}
		if(url)return url
			
		var i = el.getAttribute('index')		
		if(!i)return
		
		i = parseInt(i);
		url= this.url
		
		var st, en, ind = this.inds;		
		if(i>=ind.length-1){
			st=0;en=ind[i-1]
		}else {
			st=ind[i];en=ind[i+1]
		}
		if(el.classList.contains("subdomain")){
			var newURL = url.substring(0, ind[0])+url.substring(ind[i+1], this.domainEnd)
		}else
			var newURL =  url.substring(0, en)
		//fixup jars
		if(newURL.substring(0,4)=='jar:'){
			if(newURL[newURL.length-1]=='!')
				newURL = newURL+'/'
			else if(newURL.indexOf('!')==-1)
				newURL = newURL.substr(4)
		}
		
		return newURL
	},

	selectFromRange: function () {
		var st = this.anchorOffset
		var en = this.focusOffset
		if(st>en){
			var st1 = st
			st=en
			en=st1
		}else if(st==en){//
			gURLBar.inputclicks.incrementClickCounter()
		}
		this.moveSelectionToInputField(st, en);
	},
	
	openUri: function(event){
		var href=this.hrefFromElement(event.originalTarget)
		if(!href) 
			return
		var where = whereToOpenLink(event, false, true);
		if (where == "current")
			gURLBar.value=href;
		openLinkIn(href, where,{relatedToCurrent:true,fromChrome : false})
		event.stopPropagation();
		event.preventDefault();
	},

	moveSelectionToInputField: function(start,end){
		gURLBar.layerManager.makePlain();
		this.p.focus();
		
		if(typeof start!=="number"||typeof end!=="number")
			this.p.select()
		else this.p.setSelectionRange(start,end)
	},

	onMouseUp: function(e, cursorMode){		
		if(e.button==2){
			this.moveSelectionToInputField();
			document.getAnonymousElementByAttribute(gURLBar.inputBox,
				'anonid','input-box-contextmenu').openPopup(null,1,e.clientX+1,e.clientY+1,true,true)
			e.preventDefault()
			e.stopPropagation()
		}else{
			var isSel=this.anchorOffset!=this.focusOffset || cursorMode
			var state=this.state
			var cls=e.originalTarget.classList
			if(isSel || (cls.contains('empty')&&state!='left')){
				this.selectFromRange();
			}else if(state=='left' || cls.contains("smart-text-end")){
				gURLBar.inputclicks.elipsisClick(e);
			}else if(cls.contains("protocol")){
				if(!state)
					this.selectFromElement(e.originalTarget)
				else
					this.showProtocolSuggestions(e.originalTarget)
			}else{
				this.openUri(e);
			}
		}
	},

	handleEvent: function(e){
		e.preventDefault()
		e.stopPropagation()
				
		if(!this.p.value){
			this.moveSelectionToInputField()				
			return
		}
		var self = this, x, y, cursorMode, startY = e.clientY, initialClassName = this.container.className
		
		dump(e.rangeParent, e.rangeOffset, '[][][][][][][][][][][][][][][][][][]')
		
		var onMouseMove = function(e){
			x = e.clientX, y = e.clientY
			var newFocus = self.offsetFromStart(e.rangeParent, e.rangeOffset)	
			dump(e.rangeParent, e.rangeOffset,newFocus)
			
			var xR=Math.abs(cursorRect.l-x)<10
			if(self.anchorOffset == newFocus && (y < visibleRect[xR?'m':'t']  || y > visibleRect.b)  ){
				if(!cursorMode){
					self.cursor.style.display = ''; 
					cursorMode = true;
					self.cursor.style.left = cursorRect.l + 'px'; 
					self.container.classList.remove('top')
				}
			}else if(cursorMode){
				self.cursor.style.display = 'none';
				cursorMode = false
				self.container.classList.add('top')
			}
			
			if(newFocus==self.focusOffset)
				return
			self.focusOffset = newFocus;
			self.setInnerHTML(self.getMarkedTokenList(self.anchorOffset, self.focusOffset))
		}
		
		var onScrollInterval = function(){
			//dump(x , visibleRect.l, visibleRect.r, visibleRect.scrollL, visibleRect.scrollW)
			if(x < visibleRect.l && visibleRect.scrollL > 0){
				var delta = x - visibleRect.l
				if(visibleRect.scrollL + delta < 0)
					delta = -visibleRect.scrollL				
			}else if(x > visibleRect.r && visibleRect.scrollL < visibleRect.scrollW){
				var delta = x - visibleRect.r
				if(visibleRect.scrollL + delta > visibleRect.scrollW)
					delta = visibleRect.scrollW - visibleRect.scrollL				
			}else
				return
			
			cursorRect.l -=delta
			visibleRect.scrollL += delta
			self.container.scrollLeft = visibleRect.scrollL
		}
		
		var onMouseUp = function(){
			window.removeEventListener("mousemove", onMouseMove, true);
			window.removeEventListener("mouseup", onMouseUp, true);
			clearInterval(timerId);
			self.cursor.style.display = 'none'
			self.container.className = initialClassName
			
			if(this.needsFocusFixup){
				gURLBar.removeAttribute("focused")			
				this.needsFocusFixup=false
			}
			
			self.onMouseUp(e, cursorMode)
		}
		
				
		this.state = gURLBar.layerManager.elipsisMask.lastTarget.type			
		this.anchorOffset = this.focusOffset = this.offsetFromStart(e.rangeParent, e.rangeOffset)
	
	
		if(!this.cursor){
			this.cursor = this.container.parentNode.appendChild(document.createElement('stcursor'))
			this.cursor.style.cssText = 'border:1px solid;display:none;position:fixed;z-index:-1;pointer-events:none'
		}
		var visibleRect = this.container.getBoundingClientRect(), cursorRect = this.getEventPoint(e, this.anchorOffset)
		visibleRect = {
			m: visibleRect.top + visibleRect.height * 0.4,
			h: visibleRect.height,
			t: visibleRect.top,
			l: visibleRect.left,
			r: visibleRect.right,
			b: cursorRect.b-2,
			w: visibleRect.width,
			scrollW: this.container.scrollWidth,
			scrollL: this.container.scrollLeft
		}
		if(!this.linkable)
			visibleRect.m = visibleRect.b+10 // non uris are always selectable
		this.cursor.style.height = (visibleRect.h)+'px'
		
		this.container.setCapture(false)		
		window.addEventListener("mouseup", onMouseUp, true);
		window.addEventListener("mousemove", onMouseMove, true);

		if(visibleRect.scrollW >= visibleRect.w)
			var timerId = setInterval(onScrollInterval, 40);
		
		onMouseMove(e)
	},
	
	getEventPoint: function(e, startOffset){
		var node = e.rangeParent, offset = e.rangeOffset
		if(node.nodeType != 3) try{
			var i = this.inds.indexOf(startOffset)-1
			if(i>0){
				node = this.container.firstChild.children[i].firstChild
				offset = node.length
			}else{
				node = this.container.firstChild.children[0].firstChild
				offset = 0
			}
		}catch(e){return {left:0, height:0}}
		
		var range = document.createRange();
		
		range.setStart(node, offset)
		range.setStart(node, offset)
		var b1 = range.getBoundingClientRect()
		range.detach()
		
		return {l:b1.left, h:b1.height, b:b1.bottom}
	},
	

	offsetFromStart: function(node, offset) {
		function getLength(node){
			if(!node)
				return 0;
			if(node.nodeType == 3 )
				return node.length
			var ch=node.childNodes
			if(!ch)
				return 0;
			var l=0,n=ch.length, i=0
			for(i=0;i<n;i++)
				l+=getLength(ch[i])
			return l
		}
		function getLength2(node, offset){
			if(!node || !offset)
				return 0;
			if(node.nodeType == 3 )
				return offset
			var ch = node.childNodes
			if(!ch)
				return 0;
			var l=0,n=offset, i=0
			for(i=0;i<n;i++)
				l+=getLength(ch[i])
			return l
		}
		
		var l = getLength2(node, offset)
				
		while(node && node !== this.container){
			var newNode = node.previousSibling
			while(newNode){
				l+=getLength(newNode)
				newNode = newNode.previousSibling
			}
			node = node.parentNode;
		}		
		return  l
	}
})]]> </field>

<field name="inputclicks"><![CDATA[({
	p: this.inputField,

	init: function(){
		this.p.addEventListener("mousedown", this, true);
		this.p.addEventListener("mouseup", this, true);
	},

	stopEvent: function(event){
		event.stopPropagation();event.preventDefault()
	},

	elipsisClick: function(event){
		if(event.button==0){
			var e,l,p
			p=this.p
			l=p.value.length;
			if(l!=0&&0==p.selectionStart&&l==p.selectionEnd){
				p.selectionStart=l
			}else{
				p.select();
			}
			this.clickCount=0
		}else if(event.button==2){
			if(!gURLBar.plain){
				gURLBar.layerManager.makePlain()
				this.p.focus()
			}
			this.p.select()
			if(event.button==2)
				document.getAnonymousElementByAttribute(gURLBar.inputBox,'anonid','input-box-contextmenu').openPopup(null,1,event.clientX+1,event.clientY+1,true,true)
		}else if(event.button==1){
			openDialog('chrome://smarttext/content/options.xul','','centerscreen')
		}
	},

	incrementClickCounter: function(reset){
		clearTimeout(this.clickCountTimer);
		if(reset){
			this.clickCount=0
			return
		}
		var self=this;						
		this.clickCountTimer= setTimeout(function(){
			self.clickCount=0
		}, this.DBL_CLICK_SPEED+100*Math.min(this.clickCount,3))
		this.clickCount++
	},
	
	handleEvent: function (event) {
	  switch (event.type) {
		case "mousedown":			
			if(event.button!=0){
				this.incrementClickCounter('reset')
				return;
			}
			var p=this.p,l=p.value.length,e=event.rangeOffset;			
			
			this.incrementClickCounter()
			
			var curpos=event.clientX+" "+event.clientY
			if(e==l&&(this.clickCount!==1||curpos==this.lastPos)){
				if(event.detail>1)this.stopEvent(event)				
				if(p.selectionStart==l&&p.selectionEnd==l){				
					p.selectionStart=0
					this.ecbc=1			
				}else if(p.selectionStart==0&&p.selectionEnd==l){
					p.selectionStart=e
					this.ecbc=2				
				}
			}else if(this.clickCount === 1){
			   if(event.detail>1){
					p.selectionStart=p.selectionEnd=e
					this.stopEvent(event)
			   }
			}else if(p.selectionStart==0&&p.selectionEnd==l){
				this.clickCount=0
				p.selectionStart=p.selectionEnd=e
				// this.ecbc=true
				this.stopEvent(event)
			}else{
				if(this.clickCount === 3&&e==l)
					p.select();
				else
					this.extend(p.selectionStart,p.selectionEnd)
				this.stopEvent(event)
			}
			this.lastPos=curpos
			break;			
		case "mouseup":
			//handle clicking at end
			if(event.button==0&&this.ecbc){			   
				this.p.selectionStart=(this.ecbc==1?0:event.rangeOffset)
				this.ecbc=false 
				this.clickCount=0
			}
			break;
		}
	},

	selectAll: function (event) {
		this.p.select()
	},

	DBL_CLICK_SPEED:400,
	clickCount : 0,
	clickCountTimer : null,

	selectGroup:function(index){
		var url=this.p.value
		var i1= url.indexOf("://")
		var i2= url.indexOf("/",i1+3)
		var i3= url.indexOf("?",i2+1)
		if(i3<0)
			i3=url.length
		var i4= url.indexOf("#",i2+1)
		if(i4<0)
			i4=url.length

		if(index<i1){
			this.p.setSelectionRange(0, i1);
		}else if(index<i2){
			this.p.setSelectionRange(i1, i2);
		}else if(index<i3){
			this.p.setSelectionRange(i2, i3);
		}else if(index<i4){
			this.p.setSelectionRange(i3, i4);
		}
	},

	extend: function (s, e) {
		var c="";
		var p = this.p.value;
		var index = (function (c, i) "_-: .=/&?#".indexOf(p.charAt(c), i));
		var bound = Math.min(index(s - 1) || 100, index(e) || 100) + 1;

		end = e;
		while (index(end, bound) < 0) {
			++end;
			c = p.charAt(end);
		}
		end;
		start = s - 1;
		while (index(start, bound) < 0) {
			--start;
			c = p.charAt(start);
		}
		++start;
		this.p.selectionStart = start;
		this.p.selectionEnd = end;
	}
})]]></field>

<field name="layerManager"><![CDATA[({
	bar:this,
	inputLayer: this.inputField.parentNode.parentNode,
	smartLayer: this.stsegmentLayer,
	inputElement: this.inputField,
	elipsisMask:document.getAnonymousElementByAttribute(this, "class", "elipsis-mask"),

	containerElement: this.stsegmentLayer.parentNode,
	init: function(){
		//adding class first time resets original class somewhy
		//this.inputLayer.className='textbox-input-box plain smart-text-input'
		//this.smartLayer.className='smart-text '

		//
		this.elipsisMask.addEventListener("mouseover",this.m1,true)
		var l=this.elipsisMask.lastChild
		l.type='left'
		l.previousSibling.lastChild.type='top'

		this.elipsisMask.lastTarget=l
	},
	makePretty: function(){
		this.elipsisMask.style.display=""
		this.smartLayer.style.display=""

		var pstyle=this.inputLayer.style
		pstyle.maxWidth="0"

		this.smartLayer.scrollLeft = this.inputElement.editor.rootElement.scrollLeft;
		gURLBar.plain=false;
	},
	makePlain: function(){
		this.elipsisMask.style.display="none"
		var scrollLeft=this.smartLayer.scrollLeft
		this.smartLayer.style.display="none"

		var pstyle=this.inputLayer.style
		pstyle.maxWidth=""
		//pstyle.visibility=""

		this.inputElement.editor.rootElement.scrollLeft = scrollLeft;
		gURLBar.plain=true
	},
	synch: function(val){
		var url=val
		if(!url){
			selectionManager.emptySynch()
			return true;
		}try {
			var uri = makeURI(url, null, null);
			try {
				uri = typeof uri.host != "undefined" ? uri : {};
			} catch (e) {
				uri = {};
			}
		}catch(e) {
			uri = null;
		}
		
		if (!uri) {
			this.bar.selectionManager.simpleSynch(url);
			return null;
		}
		this.bar.selectionManager.synch(uri, url);
		return true;
	},
	m1: function(e){
		var [l1,l2]=[this.lastTarget,e.target]
		var clist=gURLBar.plain? gURLBar.layerManager.inputLayer.classList:
								 gURLBar.layerManager.smartLayer.classList;
		l1.type&&clist.remove(l1.type)
		l2.type&&clist.add(l2.type)

		//l1.style.background=''
		l1.style.pointerEvents='auto'

		//l2.style.background='rgba(150,150,200,0.1)'
		l2.style.pointerEvents='none'

		this.lastTarget=l2
	}
})]]></field>

		</implementation>
    <handlers>
<handler event="focus"><![CDATA[
dump('--focus', this.mIgnoreFocus, this._focused, event.originalTarget)
if(event.originalTarget == this){
	event.preventDefault()
	event.stopPropagation()
	return
}
	//if (this.hasAttribute("focused"))
	//	return;
	//dump('--focus', this.mIgnoreFocus, this._focused, event.originalTarget)
	if (!this._focused && (event.originalTarget == this.inputField|| event.originalTarget == this)) {
		this._focused = true;
		this.inputField.focus()
		if (!this.plain){
			this.layerManager.makePlain();
			this.inputField.select()
			this.plain=true
		}
	}
	//this.setAttribute("focused", "true");
]]></handler>
<handler event="blur"><![CDATA[
	//dump('--blur', this.mIgnoreFocus, this._focused, event.originalTarget)
	if (!this.mIgnoreFocus&&this._focused) {
		this._focused = false;
		if(this.plain){
			this.layerManager.synch(this.inputField.value)
			this.layerManager.makePretty()
		}
	}
]]></handler>
<handler event="mousedown" phase="capturing">
<![CDATA[
dump('gurlbar 0----------------------------',event.clientY,this.hasAttribute("focused"),event.originalTarget)

	if(event.originalTarget==this){
		var r=this.stsegmentLayer.getBoundingClientRect()
		dump('gurlbar 01----------------------------',event.clientY ,r.top, r.bottom)
		if(r.left<event.clientX && event.clientX<r.right){
			dump('inside')
			event.preventDefault()
			event.stopPropagation()
			this.setAttribute("focused", true)
			
			this.selectionManager.needsFocusFixup=true
			/*window.getInterface(Ci.nsIDOMWindowUtils).sendMouseEvent(
				'mousedown',
				event.clientX,
				r.top+r.height/2,
				event.button, event.clickCount, null
			)*/
		}
	}


//this.mIgnoreClick = true

  
]]>
<handler event="mousedown" phase="capturing">
<![CDATA[
dump('gurlbar 1',event.clientY,this.hasAttribute("focused"),event.originalTarget)

	if(event.originalTarget==this){
		var r=this.stsegmentLayer.getBoundingClientRect()
		dump('gurlbar 01----------------------------',event.clientY ,r.top, r.bottom)
		if(r.left<event.clientX && event.clientX<r.right){
			dump('inside')
			event.preventDefault()
			event.stopPropagation()
			//this.setAttribute("focused", true)
			
			this.selectionManager.needsFocusFixup=true
			/*window.getInterface(Ci.nsIDOMWindowUtils).sendMouseEvent(
				'mousedown',
				event.clientX,
				r.top+r.height/2,
				event.button, event.clickCount, null
			)*/
		}
	}


//this.mIgnoreClick = true

  
]]>
</handler>
	</handlers>
		</binding>
</bindings>